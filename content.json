{"pages":[{"title":"","text":"XSUN 个人主页工具使用Hexo生成，hexo相关请参考hexo.io 结构branch:1. master 网页部署用 2. develop 网页生成用的hexo工程文件 文件* scaffolds 生成文章，草稿或者网站分页的模板 * source 资源文件夹，保存文章及引用到的代码或者图片 * themes 主题，为submodule，主题代码在其他repository保存。 * _config.yml 用来设置网站的各种参数，名称，连接，功能启用 * .gitignore 无视 * .gitmodules 定义submodule用 * package.json node包管理员 * package-lock.json 管理员陷饺子","link":"/README.html"}],"posts":[{"title":"Markdown 语法笔记","text":"内容整理自 markdowntutorial. 粗体和斜体斜体_Italic_输入内容的前后添加下划线，使字体变为斜体。 粗体**Bold**输入内容的前后添加星号，使字体变为粗体。 删除线~~删除线~~输入内容的前后加波浪线，在文字上添加删除划线。 标题123456# Header one## Header two ### Header three#### Header four##### Header five###### Header six 链接完整的链接[XSUN的主页](https://xsun4231.github.io/)效果： XSUN的主页链接的书写格式： 方括号+圆括号的组合 方括号内为页面显示内容，圆括号内为链接URL 参照12345[从这里进入][url名][从这里也可以][url名][这里也行][url名][url名]: https://xsun4231.github.io/ 从这里进入从这里也可以这里也行 设置参照与设置链接方法基本相同，只是在链接URL前面单独设置一个标签，标签可反复使用。 插入（图片） ![这是一张很可爱的图片](https://octodex.github.com/images/spidertocat.png) 图片的是指方法与链接的设置方法基本相同，只是在方括号前面添加叹号。 图片的链接同样可以设置为参照 引用&gt; 孟子曰：孔子说的对。 孟子曰：孔子说的对。 在文字块(以换行结束)前添加大于号(右尖括号)，则将整个文字块设置成引用。将多个段落设置成一个引用块时，在每一个新段落(换行后)添加大于号。 列表1234567891011* milk* egg* apple 1. fuji 2. fuji2 3. fuji3* banana* people 1. AAA 1. BBB 1. CCC milk egg apple fuji fuji2 fuji3 banana AAA BBB CCC 列表用星号来标记，在星号前添加缩进来增加层次，使用数字代替星号可以将标签变为数字。 段落123第一段第二段第三段 代码块外的单一换行不会被识别，可以使用多个换行来制造强制换行，不过会造成很大的间距。 第一段第二段 第三段 标准的换行是在行位添加两个空格： 第一段第二段第三段 代码块1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' ` 是键盘左上角Esc下面那个，不是单引号’ 12345678910三个` @requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world'三个` 图表12345| ID | NAME | AGE || :---- | ----: | :---: || 00001 | AAAA | 5 || 002 | BB | 12 || 03 | CCC | 9 | ID NAME AGE 00001 AAAA 5 002 BB 12 03 CCC 9","link":"/2017/11/18/2017-11-18-Markdown/"},{"title":"IDE使用备忘录","text":"“这里应该怎么设置来着？ ” EclipseWeb Application Library添加本地jar包在项目上右键 -&gt; Deployment Assembly -&gt; add -&gt; project. 显示/隐藏 空白符号在 Windows/Preferences/General/Editors/Text Editors 中通过勾选 Show whitespace characters 来设置是否显示空白符号点击右侧的configure visibility，还可以进行具体(比如换行符)的设置. 隐藏状态 显示状态 Intellj IDEApropertity文件相关显示文字而不是ASCII编码直接打开propertity文件的话，UTF-8编码会直接显示ASCII编码而不是文字，可以在设置里修改：File -&gt; Setting -&gt; Editor -&gt; File Encoding 大约中间靠下的位置，勾选transparent native to ascii conversion就可以显示文字而不是直接显示ASCII编码了。 修改ASCII编码的默认大小写使用ASCII码的property文件在IDEA中编辑会默认使用大写字母(例：使用 \\u00E3 而不是 \\u00e3)如果想要保存成小写字母，需要在IntellJ的根目录下找到 idea.properties，在其中添加：idea.native2ascii.lowercase=true","link":"/2017/12/22/2017-12-22-IDE_memo/"},{"title":"JavaScript 基本知识备忘录","text":"介绍JavaScript使用的是ECMA(European Computer Manufacturers Association)的ECMAScript标准,也就是人们常说的ES6,ES7,ES8.而JavaScript本身是网景公司(Netscape)对ES标准的一种实现,JavaScript是该公司的注册商标.(这也是前阵子苹果下架了所有名称里带JavaScript的app的原因) JavaScript 是Brendan Eich用两周写出来的一种语言.所以有点设计缺陷也可以理解,比如typeof null == &quot;object&quot;由于浏览器确定了使用的JavaScript版本,所以写JavaScript程序时,要注意ES版本与浏览器的支持是否匹配. 基本写在哪里JavaScript的代码可以直接写在网页html里,也可以单独写在js文件中.html里的JavaScript代码要写在 &lt;scrpt&gt; 标签内,标签的 type 属性不需要定义： 1234567891011&lt;head&gt; &lt;script&gt; alert('Hello, World!'); &lt;/script&gt;:&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt;```我们也可以把```alert('Hello, World!')```单独写在一个js文件中,取个名字`hello.js`,然后把js文件的引用写入html的head中(其实写在body里也能跑) ... 1234567### 简单语法JavaScript每个语句以`;`结束,JavaScript的引擎会自动添加,所以这里并不强制要求,不过因为自动添加的`;`有时会造成歧义,所以手动添加还是最保险的.赋值语句```JavaScriptvar x = 1; 条件判断 123if( 1 &gt; 0 ){ x = 1;} 一般规范：4空格缩进,80字换行 另外跟Java一样,JavaScript的注释写法也是//和/* */,JavaScript也对大小写敏感. 变量 JavaScript是动态语言,变量的声明使用var,赋值使用**=**. 使用var声明的变量其作用域都在函数内，而不使用var声明的变量则是全局变量. 变量名要求由大小写英文,数字,$和_组成,不可以用数字开头,也不可以使用JavaScript的关键字作为变量名. 数据类型基本型JavaScript有五种基本类型： number string boolean undefined null 12345typeof 1;//&quot;number&quot;typeof &quot;abc&quot;;//&quot;string&quot;typeof true;//&quot;boolean&quot;typeof undefined;//&quot;undefined&quot;typeof null;//&quot;object&quot; 数字型 NumberJavaScript中数字型不区分整数和浮点数,正、负、整数、浮点数、NaN、Infinity都是Number型,可直接进行运算. NaN: Not a Number Infinity: ∞ 无穷大 字符串JavaScript中字符串可以用双引号&quot;,也可以用单引号'来表示. 布尔型JavaScript中的布尔型由true和false构成,以及 与,或,取反的运算都与Java相同. JavaScript中进行比较的时候,如果使用==,会自动转换类型再进行比较,不转换类型的比较则需使用三个等号===. NaN与所有Number都不相等,包括它自己,判断NaN的时候只能使用isNaN(). 1234isNaN(NaN) //true&gt;// function isNaN(a){&gt;// return a != a;&gt;// } JavaScript的浮点数在运算时会产生误差,直接进行比较会出现错误结果.这点在Java中也是一样，所以要进行精确比较的时候,不应该使用浮点型. 可以通过检测误差绝对值来进行比较: 1Math.abs(1/3 - (1 - 2/3)) &lt; 0.000001; \\\\true 空值和未定义JavaScript中类似于Java,也通过null来表示空值,空值与长度为零的字符串不同.JavScript同时还定义了一个表示未定义的常量undefined.一般在检测参数时可以用到,未输入的参数会被当做undefined处理. 引用类型数组 ArrayJavaScript通过[]来表示数组,使用,来分隔元素.也可以用new Array(1,2,3);来定义数组.数组中的元素可以是任意的数据类型,通过索引arr[index]来访问. 对象 ObjectJavaScript的对象是由成对的key-value组成的无序集合.key都是字符串,value可以是任意数据类型. 1234567var person = { name: 'Bob', age: 23, tags: ['person', 'young'], married: false, code: null} 通过以下格式获取对象的属性： 12person.name;// Bobperson.age; // 23 作用域传统的编程语言,作用域一般是块级,也就是一个{}内是一个作用域,所以在if else while for的范围内定义的局部变量不会影响到外面.而JavaScript的作用域是函数级,一个function为一个作用域,在函数内部定义的变量,不受函数内部语法块的影响. 12345var x = 1; // 1if(true){ var x = 2; //2}condole.log(x); //2 如果一定要实现块作用域的话,便需要插入函数来起到划分的作用 1234567var x = 1; //1if(true){ function print(){ var x = 2;//2 }}console.log(x);//1 函数作用域提升函数声明分为：声明式 和 变量式 声明式会自动将声明放在函数最前面,并执行赋值的内容. 123function name(){} 所以下面的函数没有问题 1234test(&quot;test&quot;);function test(arg){ console.log(arg); //test} 变量式会将声明提升到函数最前,而后再赋值 123var name = funciton(){} 所以下面的代码中,函数被声明之后,还没有赋值,便被执行,会报错. 1234baz(&quot;baz&quot;); //baz is not a functionvar baz = function(arg){ console.log(arg);}; 需要注意的是,变量式声明中的函数,是不会被提升作用域的 123456789var baz = function spam(arg){ if(arg &lt; 5){ spam(arg + 1);//只在函数的作用域内有效 }else{ console.log(arg); }};baz(1); //5spam(1);//spam is not defined 使用var声明的变量或者函数,要放到其作用域的顶端.","link":"/2018/04/26/2018-04-26-JavaScript/"},{"title":"JavaScript 两种常用的函数定义方法","text":"JavaScript中定义函数，通常会遇到以下两种写法： 写法A 123function name1(){ //...} 写法B 123var name2 = function(){ // ...}; 这两种写法有什么区别呢？很久很久以前,stackoverflow上面有人问了一样的问题。 funciton的基本定义首先，在JavaScript中function的最基本定义方法是写法A，这种定义的内容在脚本被编译时就会执行，生成一个有名字的函数对象。 而写法B实际上是定义了一个无名的函数对象，又将这个对象赋给了一个有名字的变量。这种写法的存在，方便了我们将函数定义为对象的属性： 12345var target = new Object();target.add = function(a,b){ return a+b;};target.add(1,1); //2 所以写法A定义的是一个完整的函数对象，而写法B定义的函数是没有名字的，name2是变量的名字，而不是函数的。 扩展其实还可以使用new来声明函数： 1var name = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a+b;&quot;); 这里注意使用的是Function而不是function，这是具体的定义了一个Function类型的对象。速度慢，只有在特定情况下使用，比如想要让用户去控制函数内容的时候。","link":"/2018/07/17/2018-07-17-FunctionDefinition/"},{"title":"Java 中的NaN","text":"介绍在学习JavaScript时看到了Number类型中的NaN和Infinity，因为概念本身是通用的，所以趁机总结了一下Java中的NaN和Infinity。 基本Java的Float型和Double型各有三个很特别的常量：NaN(非数），POSITIVE_INFINITY(正无穷)，NEGATIVE_INFINITY(负无穷) Float 1234567891011121314151617181920/** * A constant holding the positive infinity of type * {@code float}. It is equal to the value returned by * {@code Float.intBitsToFloat(0x7f800000)}. */public static final float POSITIVE_INFINITY = 1.0f / 0.0f;/** * A constant holding the negative infinity of type * {@code float}. It is equal to the value returned by * {@code Float.intBitsToFloat(0xff800000)}. */public static final float NEGATIVE_INFINITY = -1.0f / 0.0f;/** * A constant holding a Not-a-Number (NaN) value of type * {@code float}. It is equivalent to the value returned by * {@code Float.intBitsToFloat(0x7fc00000)}. */public static final float NaN = 0.0f / 0.0f; Double 1234567891011121314151617181920/** * A constant holding the positive infinity of type * {@code double}. It is equal to the value returned by * {@code Double.longBitsToDouble(0x7ff0000000000000L)}. */public static final double POSITIVE_INFINITY = 1.0 / 0.0;/** * A constant holding the negative infinity of type * {@code double}. It is equal to the value returned by * {@code Double.longBitsToDouble(0xfff0000000000000L)}. */public static final double NEGATIVE_INFINITY = -1.0 / 0.0;/** * A constant holding a Not-a-Number (NaN) value of type * {@code double}. It is equivalent to the value returned by * {@code Double.longBitsToDouble(0x7ff8000000000000L)}. */public static final double NaN = 0.0d / 0.0; NaNNaN是Not a Number的缩写，表示未定义或者不可表示的值，NaN有一个特性，那就是它与任何数都不相等，包括它自己。判断一个数是不是NaN，只能使用Float或者Double的isNaN()方法，那么这个方法是怎么判断的呢？我们看一看(查看的是Float版，Double除了参数类型都一样，下面二者没有区别的部分都直接使用Float的内容来说明)： 1234567891011/** * Returns {@code true} if the specified number is a * Not-a-Number (NaN) value, {@code false} otherwise. * * @param v the value to be tested. * @return {@code true} if the argument is NaN; * {@code false} otherwise. */public static boolean isNaN(float v) { return (v != v);} 所以，跟自己不相等的数字，就是NaN. 计算中产生的NaN什么时候会产生NaN呢？首先，任何与NaN进行的运算，其结果都是NaN.比如下面的运算，不要去想太多，结果就是NaN 1234567public class Test { public static void main(String[] args) { var x = Float.NaN; var y = x - x + 1; System.out.println(y); }} 其次，从数学角度讲，无法进行的运算(N/0)或者会产生复数的运算(sqrt(-N))，都会产生NaN。 (咕咕咕，后面的笔记被鸽了)","link":"/2018/05/29/2018-05-29-NaN/"},{"title":"Immediately_Invoked_Function -- 立即调用函数的写法","text":"自执行-立即调用的函数表达式在某些情况下，我们不需要函数创建多个实例，也不需要对返回值做什么处理，便可以通过在函数声明的后面添加()来实现自执行。因为foo仅仅是function(){}这个表达式的一个引用，在函数表达时候后添加()便可以执行。 123var foo = function(){ //do something.}(); 但如果我们像下面这么写，会报错： 123function(){ //do somthing.}(); 给括号里加入参数的话，可以不报错，但是函数不会执行，因为它会被解析成一个毫不相关的括号。报错原因：解析代码的时候，function已经被识别为声明函数用，而不是一个函数表达式。所以我们要做的就是把括号前面的内容解析成表达式，以下的写法都可以： 12345678910111213141516171819202122232425262728293031(function makeCounter(){ console.log(&quot;invoked by ()&quot;);}());var x = function makeCounter(){ console.log(&quot;invoked by var with ()&quot;);}();!function(){ console.log(&quot;invoked by !&quot;);}();~function(){ console.log(&quot;invoked by ~&quot;);}();+function(){ console.log(&quot;invoked by +&quot;);}();-function(){ console.log(&quot;invoked by -&quot;);}();new function(){ console.log(&quot;invoked by new&quot;);};new function(){ console.log(&quot;invoked by new with ()&quot;);}();","link":"/2018/06/20/2018-06-20-ImmediatelyInvokedFunctionException/"},{"title":"LBL法还原魔方","text":"我写的东西，自己都看不懂 魔方的基本结构国际标准的魔方（Rubik’s Cube) 由黄蓝红绿橙白6个中心块，8个角，12个棱，组成。魔方颜色的位置关系是：上黄下白，前蓝后绿，左橙右红。 魔方入门级复原步骤 原参考链接LBL(Layer By Layer)法，复原过程以上黄下白为例。 第一层目标：复原最下面一层：底面复位，层面看可以构成四个凸型 首先，不在意侧面颜色，将四个白色棱块移动到上方（白面朝上），转动上层，将白色棱块侧面颜色移动到对应的面，180旋转侧面，将白色棱块移动到底部。然后，使用左手或者右手公式，将上方的角块移到下方对应的夹角处。如果颜色方向不符合，就使用同一公式多转几次。 第二层目标：复原中层的四个棱 - 完成两层 现在底面已经复原，侧面看四个小凸型也完成，使用左手公式-整体右转-右手公式（或者 右手公式-整体左转-左手公式）将上方的棱块移动到中层。 第三层（顶面）目标：顶面复原 首先，使用拐角或者一字公式，将顶面复原成十字。然后连续的使用左小鱼或者右小鱼，先转出左（右）小鱼型的顶面，再对应的解决掉，就完成了顶面。 第三层（侧面）目标：完全复原 观察顶层侧面的颜色结构，如果发现有至少一对眼，就将有眼的一面放到左手，做一遍一字公式+拐角公式；如果没有眼，就做一遍拐角公式+一字公式；如果全是眼….就进行下一步。（此时顶层的四个顶角应该都已经复原了）使用左小鱼-上层右转-右小鱼（或者右小鱼-生成左转-左小鱼），可以将面前的两个角块和左侧（右小鱼起手则是右侧）的棱块移动到一起，这样魔方就复原了。","link":"/2019/02/05/2019-02-05-rubik-cube/"},{"title":"jQuery 基本知识点备忘录","text":"$(document).ready()页面载入需要首先准备DOM（Document Object Model),jQuery可以检测到页面的DOM是否准备完毕，$(document).ready(function)中的function，会等到页面的DOM准备完毕再运行。类似的还有$(window).on(&quot;load&quot;,funciton),这种写法下的function会在整个页面（并不仅仅是DOM）载入完毕时再执行。 1234567$( document ).ready(function() { console.log( &quot;document loaded&quot; );});$( window ).on( &quot;load&quot;, function() { console.log( &quot;window loaded&quot; );}); 将上面的代码插入页面的某个部件里执行，可以看到document很快就载入完成，等页面的所有其他元素都载入完成，window loaded才会被执行输出。","link":"/2019/03/19/2019-03-19-jQuery-Memo/"},{"title":"Embadded-JavaScript","text":"Ejs 文件是什么嵌入式JavaScript代码：Embadded JavaScript 是一种从JavaScript快速生成html的简易模板，详细说明可以阅读说明文档 Ejs 中文文档。Hexo网页使用ejs的时候，使用命令 npm install hexo-renderer-ejs --save， 添加ejs的支持就可以了。这里作为备忘录，简单记录一下标签的写法。 标签 &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除 整理一下就是说，ejs代码就是写在html中的javascript，标签是&lt;% %&gt;,标签的开头和结尾有几中命令符可以使用，分别是 _ 删除空格; =输出数据; - 在前：输出非转义数据（比如插入处理），在后：删除换行; # 注释; % 用于输出 &lt;% 插入自定义“转义符” （官方文档写的是分隔符-delimiters，不是很理解）","link":"/2019/03/20/2019-03-20-Embadded-JavaScript/"},{"title":"python 中的字符串格式化","text":"原文： python-f-string 自3.6版本开始，python引入了一种叫做f-strings的写法，使用改写发可以极大地增强字符串的可读性（当然好处不止这些).不过在学习f-strings之前，先看看以往的写法都有哪些。 旧方法在3.6之前，我们常用的字符串格式化写法有两种： 使用转移符 % 使用字符串的格式化方法 str.format() 旧选项1 %跟其他编程语言一样，python也可以用%来把变量值插入到字符串中的对应位置。写法如下： 123name = 'Tom'print('Hello %s.' % name)# 输出结果: 'Hello Tom.' 输出多个变量时，在%后使用括号将所有变量放到一起： 123456name1 = 'Tom'name2 = 'Jerry'type1 = 'cat'type2 = 'god'print('Hello %s, you are a %s.this is %s, a %s' % (name1, type1, name2, type2))# 输出结果: 'Hello Tom, you are a cat. this is Jerry, a god' 但是转移符这种东西，一个不小心就容易写错。 旧选项2 str.format()从2.6开始，python为字符串添加了一个format()方法，可以将引入的参数按顺序替换到字符串中的{}处。例如： 123456name1 = 'Tom'name2 = 'Jerry'type1 = 'cat'type2 = 'god'print('Hello {}, you are a {}.this is {}, a {}'.format(name1, type1, name2, type2))# 输出结果: 'Hello Tom, you are a cat. this is Jerry, a god' 使用format()你还可以自定义参数的插入顺序，例如： 123456name1 = 'Tom'name2 = 'Jerry'type1 = 'cat'type2 = 'god'print('Hello {0}, you are a {2}.this is {1}, a {3}'.format(name1, name2, type1, type2))# 输出结果: 'Hello Tom, you are a cat. this is Jerry, a god' format()方法的功能还不止于此，既然index可以用来出入参数，那可不可以用参数名称呢？毕竟0,1,2,3的可读性有限。答案是可以： 123456name1 = 'Tom'name2 = 'Jerry'type1 = 'cat'type2 = 'god'print('Hello {name_a}, you are a {type_a}.this is {name_b}, a {type_b}'.format(name_a = name1, name_b = name2, type_a = type1, type_b = type2))# 输出结果: 'Hello Tom, you are a cat. this is Jerry, a god' 既然可以这样写了，那干脆直接引入dict得了.这个也是可以的： 123456character = { 'name' : 'Tom', 'type' : 'cat'}print('Hello {name}, you are a {type}.'.format(**character))# 输出结果: 'Hello Tom, you are a cat.' 这样可读性就非常好了，不过在3.6版本，更好的写法出现了。 新方法关于f-string的引入，可以参看PEP498, 或者Python-doc. 写法非常简单，在字符串前加f或者F，在字符串中直接插入{变量名}，就可以了： 1234name = 'Tom'type = 'cat'print(f'Hello {name}, you are a {type}.')# 输出结果: 'Hello Tom, you are a cat.' 在{}中不仅可以使用字符串，还可以使用运算公式，甚至调用方法： 12345def change_name(input): return 'Jerry'name = 'Tom'print(f&quot;Hello {change_name(name)}.&quot;)# 输出结果: 'Hello Jerry.' 当使用object时，f-string会默认调用__str__()方法，如果想调用__repr__，需要在对象名后面加!r： 1234f&quot;{object}&quot;# 输出 object.__str__()的内容f&quot;{object!r}&quot;# 输出 object.__repr__()的内容 最后一个考点：换行。在python中可以使用'''来输出带有换行的字符串，不过直接在前面加上f的结果并不怎么好看： 123456message = f'''Hi,you are a Cat'''# message : '\\nHi, \\nyou are a \\nCat\\n' f-string的换行方法是，在每行的最后添加\\ 12345message = f''\\f'Hi '\\f'you are a '\\f'Cat '# message ： 'Hi you are a Cat' 注意 一般情况下f-string使用单引号和双引号没有区别，但比如引用字典，需要单引号来标记key时，f-stirng就需要使用双引号了，否则字符串中的单引号会被错误理解。","link":"/2019/04/12/2019-04-12-python-f-strings/"},{"title":"Hexo 说明文档笔记","text":"Hexo 文档 theme文件夹结构 _config.yml languages layout scripts source _config.yml主题的配置文件，修改主题的配置文件不需要重启服务器（修改网站根目录的那个_config.yml则需要重启才能生效) languages国际化设置，使用yml文件设置网站元素的翻译，具体参考i18n layout网页、模板的设置。hexo默认使用Swig,不过也可以手动添加EJS,Haml,Jade或者Pug的支持。模板的写法参考 Templates scripts存放JavaScript代码的文件夹，Hexo会自动加载这里的javaScript文件。扩展功能参考 plugins source顾名思义，这里是存放资源的。不属于页面模板的资源理论上都应该在此文件夹下面。 模板Layout 布局在主题文件夹下的layout中定义不同模板的页面的呈现方式，具体的模板文件定义了页面的body内容，而layout则定义了如何显示body。比如在布局中这样写： 1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;&lt;%- body %&gt;&lt;/body&gt;&lt;/html&gt; 系统默认的布局为layout布局，不过在post的头部可以通过定义来使用具体的布局。 Partial 组件不同页面之间共享的内容可以写成组件来管理，比如Header,Footer,Sidebar。引用组件时： 1&lt;%- partial('partial/header') %&gt; 变量资源文件夹从Hexo 3 开始，在_config.yml中启用post_asset_folder=true, 使用hexo的资源文件夹功能。启用后，_posts里每生成一个post，会在相同路径下生成一个同名的文件夹作用该post的资源管理文件夹。 引用资源文件夹中的资源启用了asset_folder后，可以使用以下几种命令，在文章中引用资源: 123{% asset_path name %}{% asset_img name title %}{% asset_link name title %} 在name的地方填写资源文件夹内的相对路径。 比如以下的文件结构： 1234- sample.md- sample - part1 - img.jpg 在sample.md中引用img.jpg时的写法是: 1{% asset_img part1\\img.jpg this is title %} 优点使用资源文件夹与使用markdown的引用语法的最大不同就是：在网站首页或者归档处显示时，使用资源文件夹功能的引用可以被显示，而markdown语法引用的内容则无法被正确显示。 样板 国际化 i18ni18n (Internationalization) 是指针对不同的国家、地域、语言环境，改变网站通用部分的显示语言。 设置使用YAML或者JSON编写不同的语言文件，并统一放在主题文件夹languages中。 使用使用__或者_p来取得对应语言的字符串。比如： 1234menu： titile: HOME archive: ARCHIVE search: SEARCH 1234menu： titile: 首页 archive: 归档 search: 搜索 在模板中使用目录时（例如语言是英文）： 123&lt;%= __('menu.title') %&gt; // HOME&lt;%= __('menu.archive') %&gt; // 归档&lt;%= __('menu.search) %&gt; // 搜索","link":"/2019/04/05/2019-04-05-Hexo/"},{"title":"通过命令行从本地推送代码到GitHub","text":"首先，Git和GitHub不是一个东西。Git是一个版本管理系统，而GitHub是一个用来保存软件代码的平台。我们不妨把git看作是通讯技术，而github只是一个通讯服务商。也就是说除了github之外，还有很多的代码托管平台，大家都是用的git来上传下载代码，只不过github名气最大。 为了不受各种不同的软件影响，这里说的都是通过命令行操作. 这里只介绍一些最基本的命令和用法，在命令后面加 --help可以查看详细的文档. 环境搭建首先要做的事安装git，下载地址在这里. git安装完之后，打开命令行执行git --version看看是否可以查看git的版本，如果返回版本信息，就OK了. git会自己安装一个git Bash, 不过git的命令行并不局限于bash，windows下直接在cmd或者powershell都可以使用. 本地的代码推送到github时，github需要验证用户的信息. 就好比你可以每次进门都填一次我叫什么，我从哪儿来，我是干什么的，也可以提前登陆好身份信息，“哔”的一声刷脸进门，这个登录的身份信息就是ssh key. 接下来的操作分为三步： 确定本地是否已经有建立好的ssh key 打开git Bash（这里需要用到Bash, windows的cmd是没有ls命令的) 输入ls -al ~/.ssh 这里一个搜索命令，返回名称为.ssh的目录信息。如果有id_rsa.pub文件，就说明已经有ssh key了. 如果没有，建立一组新的ssh key 执行命令ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;来生成一组ssh key，接下来直接按回车就可以了（文件位置使用默认位置不需要输入，passphrase默认空白，不设置，设置的话以后每次推送代码都要输密码）。 将生成的key登录到ssh-agent. 执行命令启动ssh-agent，windows：eval $(ssh-agent -s) Mac或者Linux：eval &quot;$(ssh-agent -s)&quot;.然后执行命令添加key，Mac：ssh-add -K ~/.ssh/id_rsa windows或者Linux：ssh-add ~/.ssh/id_rsa 将建立好的ssh key登录到github 将ssh key的内容复制到剪贴板. window可以使用命令：clip &lt; ~/.ssh/id_rsa.pub Mac可以使用：pbcopy &lt; ~/.ssh/id_rsa.pub Linux可以使用：sudo apt-get install xclip 和 xclip -sel clip &lt; ~/.ssh/id_rsa.pub 添加到github这一步我们单独说一下，以防弄错。打开github页面，点击用户头像，进入setting，在菜单中间的位置找到SSH and GPG keys，点击右上角的绿色按钮New SSH key，在Title里填写要添加的ssh key的介绍，比如”公司那台贼慢的电脑/家里的老爷机/学校的大屁股显示器”,然后在将复制的SSH key粘贴到Key里面，点击Add SSH key就可以了。 克隆项目代码我们来到GitHub的代码页，可以在代码的右上角看到一个绿色按钮Clone or Download，点开之后可以看到克隆代码用的链接。 链接有两种，https 和 ssh， 简单来讲，使用https的链接克隆的项目需要用github的用户名密码来推送，使用ssh链接克隆的项目则使用ssh-key验证 由于我们已经设置好了ssh-key，所以使用格式为git@github.com:用户名/项目名.github.io.git的ssh链接. 1git clone git@github.com:用户名/项目名.github.io.git 新建的repository如果我们要将本地的工程文件推送到一个新建的GitHub库,首先确定两件事儿： GitHub上建立了一个空的库，README都没有的那种，可以看到这个页面 本地的工程文件初始化了git，并且没有关联其他的库. git的初始化可以使用git init命令，移除其他的关联，可以使用git remote remove name 这里的name一般是origin. 然后执行下面的命令就可以了： 123git commit -m &quot;first commit&quot;git remote add origin ssh链接git push -u origin master remote 和 localgit管理的代码有两个地方: 一个是remote 可以理解为远端，也就是指托管代码的地方，使用github时，值得也就是github服务器端 一个是local 直译本地，意译本地，他也就是本地的意思 从远端向本地同步代码，叫做pull 也就是拉，将本地代码同步到远端，叫做push 推送，简单而形象。 local值不需要，当然也不能修改，因为代码就在本地. remote的值可以随时添加，删除或者修改，remote是name和url成对设置的，一般默认的remote名是origin git remote 确认remote，会返回remote的名称 git remote get-url remoteName 获得remote的url git remote set-url remoteName url 设置remote的url branch为了实现并行的开发，代码通过branch（分支）来进行管理，不妨branch理解成时间线、河流，可分成几个分支并行前进，也可以随时汇集到一起（只要内容没有冲突）。可以通过git branch来查当前本地的分支。切换分支的命令为 git checkout &quot;branch_name&quot;常用的生成分支命令为 git checkout -b &quot;new_branch_name&quot; &quot;base_branch_name&quot;使用git branch &quot;new_branch_name也可以生成新的分支，不过该命令并不切换到新生成的分支. 分支的名称不可以有空格，所以一般通过下划线连接单词，当分支名含有特殊符号比如 # 时，需要在分支名前后加 “ 来防止控制台执行时的歧义。 commit如果说branch是时间线，那么commit就是时间线上的存档点。刚刚创建或者修改完的文件，在git中并不算保存了，如果强行修改分支，这些内容就会丢失。将修改的内容保存到branch的记录中的操作，叫做commit（提交）. 执行commit之前，首先需要把准备提交的文件添加到提交名单，这个操作使用 git add 命令。添加之前，可以通过git status命令来查看有哪些文件被修改了. 这里简单的从bash颜色上区分一下，绿色的内容(Changes to be committed) 是已经准备好可以提交的内容，红色的内容(Changes not staged for commit) 是还没有添加到提交列表的修改. 下面介绍几种简单常用的命令 1234567891011# 将所有的修改添加到提交列表git add --all# 将指定文件添加到提交列表，多个文件的时候使用空格区分git add aaa.mdgit add bbb.md ccc.md path/ddd.md# 可以使用正规表达来指定多个文件git add a*.mdgit add path/\\*.md 文件添加完，就可以执行commit来提交了： 12345# 提交的时候，commit信息是必须的，可以直接使用-m 来指定commit信息git commit -m &quot;在这里输入一条commit信息&quot;# 使用github的时候，可以在commit信息里通过 #+编号 来关联Issue，这样提交的commit可以在Issue中直接找到。git commit -m &quot;#001 commmit信息&quot; push将remote的最新内容同步到本地的命令是git pull，将本地的修改推送到remote的命令是git push. 出现冲突的时候可以加上--force来强制推送，不过这个操作不推荐，推送代码尽可能在解决冲突之后，使用最简单流畅的git push 推送命令的对象是分支，所以当我们推送本地创建的新分支时，需要指定一下这个分支在remote的信息： 12345# git push 推送命令# --set-upstream 告诉git 我要设置推送目的地# remotename 要推送到的remote名 一般是 origin# branch_name 推送的branch名 含有特殊字符的话要用&quot;branch_name&quot;git push --set-upstream remotename branch_name 无论是切换分支，还是推送的时候，如果前面命令输入正确，git bash可以补全分支名。所以多用tab不仅方便，还能帮忙检查一下分支名前面的命令行有没有错。","link":"/2019/04/15/2019-04-15-git-connect/"},{"title":"代码重构 - 简化条件语句","text":"原文 publisher logo Refactoring: Improving the Design of Existing Code Chapter 9 Simplifying Conditianal Expressions 分离条件 - Decompose Conditional很多程序之所以“复杂难懂”，是因为出现了“复杂难懂”的条件语句。当人们看到条件语句时，最想获取的信息是：if XXX 的时候，do YYY； else do ZZZ。所以简化条件语句最简单直接的方法就是把长长的判断语句或者大段大段的处理分离出来，留下最基本的if else结构，一目了然，至于具体的判断方法和处理内容，则去具体的方法中查看。 遇到有嵌套结构的条件语句时，不妨先试试先整理成卫语句(Guard Clauses)，行不通再进行分解处理。 比如我们遇到下面这段代码： 12345if (date.before (SUMMER_START) || date.after(SUMMER_END)){ charge = quantity * winterRate + winterServiceCharge;}else{ charge = quantity * summerRate;} 对条件和判断后的代码分别施放Extract Method法术: 1234567891011121314151617if (notSummer(date)){ charge = winterCharge(quantity);} else { charge = summerCharge (quantity);}private boolean notSummer(Date date) { return date.before (SUMMER_START) || date.after(SUMMER_END);}private double summerCharge(int quantity) { return quantity * summerRate;}private double winterCharge(int quantity) { return quantity * winterRate + winterServiceCharge;} 当然，每次抽离出方法的时候，都不要忘记进行测试，保证重构不会影响原本的处理结果，很多时候条件语句并不是十分复杂，看起来好像没有抽离成为方法的必要，这就要看条件语句读起来是否顺畅易懂了，如果可以把原本机器感十足的语句变得更像一段流畅直白的描述，条件语句的重构就是有意义的。 整合条件 - Consolidate Conditional Expression有些条件语句的虽然有着不同的判断条件，却执行着相同的动作。如果可以确定这些判断不需要完全的独立，不妨整合到一起，再抽离出一个方法，这样，条件语句就更有“一个判断”的感觉了。 比如下面的代码： 12345double disabilityAmount() { if (_seniority &lt; 2) return 0; if (_monthsDisabled &gt; 12) return 0; if (_isPartTime) return 0; // compute the disability amount 可以整合成： 123double disabilityAmount() { if (isNotEligableForDisability()) return 0; // compute the disability amount 整合的对象不仅仅是同等级的条件语句(使用ors），有一些嵌套的条件语句更有整合的必要（使用ands）： 1234if (onVacation()) if (lengthOfService() &gt; 10) return 1;return 0.5; 如果内层的if只是起到筛选的作用，而没有产生分支，就可以将内层条件语句跟外层整合到一起： 12if (onVacation() &amp;&amp; lengthOfService() &gt; 10) return 1;else return 0.5; 如果条件语句的处理只是返回不同的值，不妨使用三元运算符(ternary operator) 。不过要注意，三元运算符的使用因人而异，有些项目并不喜欢代码里出现三元运算符。 1return (onVacation() &amp;&amp; lengthOfService() &gt; 10) ? 1 : 0.5; 整合重复的条件语句块 Consolidate Duplicate Conditional Fragments当条件语句的if和else里出现了相同的处理时，不妨试试将其移动到条件语句之前或者之后，使条件语句中的处理更有“分歧”的感觉。 12345678if (isSpecialDeal()) { total = price * 0.95; send();}else { total = price * 0.98; send();} send()出现在具有分歧的处理之后，可以移动到条件语句的后面；如果出现在具有分歧的处理之前，则移动到条件语句的前面。 12345if (isSpecialDeal()) total = price * 0.95;else total = price * 0.98;send(); 如果无法确定整合的内容在前还是应该在后，不妨先看一看在条件语句块内，该内容的位置变化是否影响处理结果，在不影响处理结果的前提下将要整合的内容前移或者后撤之后，再进行重构就可以了。 移除控制标记 Remove Control Flag如果你使用一个变量的值控制真假的判断，不妨考虑在变量值的修改处用break或者return来替代。 比如下面的代码 123456789101112131415void checkSecurity(String[] people) { boolean found = false; for (int i = 0; i &lt; people.length; i++) { if (! found) { if (people[i].equals (&quot;Don&quot;)){ sendAlert(); found = true; } if (people[i].equals (&quot;John&quot;)){ sendAlert(); found = true; } } }} 这段代码使用变量found来判断来逃离for循环，显然可以使用break来代替： 123456789101112void checkSecurity(String[] people) { for (int i = 0; i &lt; people.length; i++) { if (people[i].equals (&quot;Don&quot;)){ sendAlert(); break; } if (people[i].equals (&quot;John&quot;)){ sendAlert(); break; } }} 这样不仅是代码看起来简洁了许多，也避免了后续得无意义的判断。当然，这里的条件语句还可以整合一下，就不细说了。 有些时候控制标记不仅仅是用来充当真假的判断条件，也用来保存返回值，这种情况可以考虑在适当的时候使用return直接结束方法： 12345678910111213141516void checkSecurity(String[] people) { String found = &quot;&quot;; for (int i = 0; i &lt; people.length; i++) { if (found.equals(&quot;&quot;)) { if (people[i].equals (&quot;Don&quot;)){ sendAlert(); found = &quot;Don&quot;; } if (people[i].equals (&quot;John&quot;)){ sendAlert(); found = &quot;John&quot;; } } } someLaterCode(found);} 我们可以先把for循环的内容抽离出来： 1234567891011121314151617181920void checkSecurity(String[] people) { String found = foundMiscreant(people); someLaterCode(found);}String foundMiscreant(String[] people){ String found = &quot;&quot;; for (int i = 0; i &lt; people.length; i++) { if (found.equals(&quot;&quot;)) { if (people[i].equals (&quot;Don&quot;)){ sendAlert(); found = &quot;Don&quot;; } if (people[i].equals (&quot;John&quot;)){ sendAlert(); found = &quot;John&quot;; } } } return found;} 可以看到标记found成为了返回值，程序的意思很明显是：[如果found不是空的，就返回其内容], 所以我们可以直接返回要赋给found的值，取消found这个变量。 12345678910111213String foundMiscreant(String[] people){ for (int i = 0; i &lt; people.length; i++) { if (people[i].equals (&quot;Don&quot;)){ sendAlert(); return &quot;Don&quot;; } if (people[i].equals (&quot;John&quot;)){ sendAlert(); return &quot;John&quot;; } } return &quot;&quot;;} 细心观察 return 的位置， 你会有意想不到的收获 使用卫语句替代嵌套的条件语句 Replace Nested Conditional with Guard Clauses条件语句在程序中的使用可以有两种思路： 用来处理明确的分支，程序往哪个方向走都有可能，完全取决于条件的真假。这种情况使用基本的if else来处理。 用来处理特殊情况，程序有着一个基本的前进方向，出现一些特殊情况时，需要立即返回特定值或者转为进行特定的处理。这种情况的条件语句，我们可以称之为 卫语句(guard clause) 当我们遇到层层嵌套的if else语句时，可以梳理一下程序的语义，如果发现条件语句的作用不是用来产生“平等”的分支，而是一种“出现了这种情况就赶快退出去吧”的感觉的话，不妨将if else简化成guard clause. 这里作者介绍的是 嵌套的条件语句 ，实际上使用卫语句的思路在单一if-else时也适用，每当我们写出一个完全体的if-else时，都应该思考一下条件语句属于那种类型，很多时候if-else的分歧处理都可以用if的卫语句解决。 比如下面的这段代码： 123456789101112double getPayAmount() { double result; if (_isDead) result = deadAmount(); else { if (_isSeparated) result = separatedAmount(); else { if (_isRetired) result = retiredAmount(); else result = normalPayAmount(); }; }return result;}; 这种梯田式的条件语句，而且处理的对象都是返回值，很明显可以使用卫语句来简化，我们从外向里，一层层的将result的赋值改为return，最后可以得到： 12345double getPayAmount() { if (_isDead) return deadAmount(); if (_isSeparated) return separatedAmount(); if (_isRetired) return retiredAmount(); return normalPayAmount();}; 使用卫语句进行重构并不局限于这一种情况，有时候我们可以发现条件语句筛选了部分情况来进行特定的处理，剩下的情况则返回默认值。这时我们可以考虑反转判断的条件式，来得到一个卫语句，今儿简化代码： 123456789public double getAdjustedCapital() { double result = 0.0; if (_capital &gt; 0.0) { if (_intRate &gt; 0.0 &amp;&amp; _duration &gt; 0.0) { result = (_income / _duration) * ADJ_FACTOR; } } return result;} 书中作者给出了详细的重构过程，这里就不细说了。 12345public double getAdjustedCapital() { if (_capital &lt;= 0.0) return 0.0; if (_intRate &lt;= 0.0 || _duration &lt;= 0.0) return 0.0; return (_income / _duration) * ADJ_FACTOR;} 工作中很常用到的一个思路就是，如果有一个大大的if框住了几乎整个方法的内容，一定要看看可不可以反转if的条件在最前面直接return，从{}中解放这段代码。 利用多态来重构条件语句 Replace Conditional with Polymorphism比如我们有下面这个结构, Employee的type为抽象类EmployeeType，被三个类实现，每个类返回的typeCode不同： 123456789101112131415161718192021222324@startumlabstract class EmployeeType{ {abstract} int getTypeCode()}class Employee{ int payAmount() int getType() private EmployeeType type}class Engineer extends EmployeeType{ int getTypeCode()}class Manager extends EmployeeType{ int getTypeCode()}class Salesman extends EmployeeType{ int getTypeCode()}Employee --&gt; &quot;1&quot; EmployeeType : type@enduml Employee的方法payAmount()的内容为： 123456789101112int payAmount() { switch (getType()) { case EmployeeType.ENGINEER: return _monthlySalary; case EmployeeType.SALESMAN: return _monthlySalary + _commission; case EmployeeType.MANAGER: return _monthlySalary + _bonus; default: throw new RuntimeException(&quot;Incorrect Employee&quot;); }} 因为type的其实是EmployeeType子类的属性，所以我们可以将这个方法移动到EmployeeType中，利用子类来实现不同的处理。首先，移动方法到EmployeeType里，由于使用了Employee才有的属性，所以我们需要将employee作为参数传递进去： 123456789101112int payAmount(Employee emp) { switch (getTypeCode()) { case ENGINEER: return emp.getMonthlySalary(); case SALESMAN: return emp.getMonthlySalary() + emp.getCommission(); case MANAGER: return emp.getMonthlySalary() + emp.getBonus(); default: throw new RuntimeException(&quot;Incorrect Employee&quot;); }} EmployeeType是抽象类，所以我们要继续将方法payAmout()在具体的子类中进行实现，不过子类中就用不到switch了。在重构的过程中，我们可以在EmployeeType中添加例外处理，比如当我们在Engineer中实现了payAmount()后: 12345678910111213141516171819class Engineer ... int payAmount(Employee emp) { return emp.getMonthlySalary(); }class EmployeeType... int payAmount(Employee emp) { switch (getTypeCode()) { case ENGINEER: throw new RuntimeException (&quot;Should be being overridden&quot;); case SALESMAN: return emp.getMonthlySalary() + emp.getCommission(); case MANAGER: return emp.getMonthlySalary() + emp.getBonus(); default: throw new RuntimeException(&quot;Incorrect Employee&quot;); } } 如此下去，直到在所有的子类中都实现了payAmount之后，将EmployeeType的方法改为abstract 1234567891011121314151617class EmployeeType... abstract int payAmount(Employee emp);class Engineer ... int payAmount(Employee emp) { return emp.getMonthlySalary(); }class Salesman... int payAmount(Employee emp) { return emp.getMonthlySalary() + emp.getCommission(); } class Manager... int payAmount(Employee emp) { return emp.getMonthlySalary() + emp.getBonus(); } 使用空对象 Introduce Null Object 空对象模式是一种需要小心使用的设计模式，而且在JavaSE8中引入Optional&lt;&gt;后，几乎用不到空对象。 插入断言 Introduce Assertion 善用 Assert.isTrue()， 确保一些必须成立的前提条件，从而让后面的条件判断达到最简化。","link":"/2019/04/22/2019-04-22-C9/"},{"title":"代码重构 - 改善方法的结构","text":"代码重构做的最多的就是改善方法的结构。去掉方法中不需要的元素，修改不明确的名称，将复杂而冗长的方法改成精简而明确的小方法群组，是重构方法的主要思路。 方法重构用的最多的是【提取方法】，有种将一地零落的玩具分类整理装箱的感觉；而【方法内联】一般在方法提取的过于详细以至于产生了反作用，或者需要重新整理方法间关系时使用。 【提取方法】的最大问题，是如何处理局部变量，这就用到了对局部变量的重构技巧。 提取方法 Extract Method如果发现方法内有一个代码块在很具体的做一件事儿，或者有一句漂亮的注释解释了接下来好几行的操作，那就试试把它提取成一个方法吧，然后取个足以说明其作用的方法名。比如： 1234567void printOwing(double amount) { printBanner(); //print details System.out.println (&quot;name:&quot; + _name); System.out.println (&quot;amount&quot; + amount);} 重构后是这个样子： 123456789void printOwing(double amount) { printBanner(); printDetails(amount);}void printDetails (double amount) { System.out.println (&quot;name:&quot; + _name); System.out.println (&quot;amount&quot; + amount);} 漂亮的代码往往方法都很简短，有着意思明确的方法名。方法越简洁，被重复利用的机会就越大；方法名如果足以传达信息，又可以省去不少的注释。方法的简洁程度和方法名的好坏是联系在一起的，提取方法可以看做是用方法名来取代原位置的代码块，如果不能通过方法名理解原本代码块要执行的操作，重构也就失去了意义。重构的时候不用刻意去思考方法或者方法名的长度，重构的关键在于方法名和代码块之间的语义距离（semantic distance)。 局部变量的处理如果要提取的代码块使用了局部变量，提取方法的操作就要变得稍微复杂一些了。首先我们需要观察一下局部变量定义、赋值以及被调用的位置，如果局部变量相关的代码可以移动位置，不妨先优化一下，因为优化前后，接下来的重构操作可能会有很大不同。 如果局部变量足够“局部”，可以直接放到新方法内部，当然是最简单的情况。 如果局部变量的赋值是在新方法的处理范围外，新方法只是调用了变量值而没有进行修改，我们可以把局部变量当做参数传达给新的方法。 如果需要新方法的处理来给变量赋值，而变量值的使用又在新方法的范围外，则需要为新方法添加返回值，返回变量值。 想返回多个变量值咋整嘞？这里涉及到了[单一返回值]的问题。编程语言普遍使用的是单一返回值的方法结构，这样可以保证代码的可读性，避免混乱。如果遇到了需要返回多个值的情况，不妨试着细化方法的划分，使用多个单一返回值的方法来实现。 栗子，重构下面代码： 123456789101112131415void printOwing() { Enumeration e = _orders.elements(); double outstanding = 0.0; printBanner(); // calculate outstanding while (e.hasMoreElements()) { Order each = (Order) e.nextElement(); outstanding += each.getAmount(); } printDetails(outstanding);} 书中直接进行了如下的重构: 123456789101112131415void printOwing() { printBanner(); double outstanding = getOutstanding(); printDetails(outstanding);}double getOutstanding() { Enumeration e = _orders.elements(); double outstanding = 0.0; while (e.hasMoreElements()) { Order each = (Order) e.nextElement(); outstanding += each.getAmount(); } return outstanding;} 书中说将outstanding的计算提取成了一个独立的方法，而前面的局部变量因为只在计算中被使用到，所以一并提取了出来。这里有一个看似理所当然却值得做笔记的操作：作者并没有将printBanner()或者printDetails()放在新方法内。如果将pringDetails()放到getOutstanding()里，不就不需要设返回值了？ 这是因为重构的对象是计算outstanding的代码块，如果将不相关的方法一并放到新方法内，就偏离了重构的目的。假设将printDetails()放在了getOutstanding()内，再看printOwing()会发现，可以获取的信息变少了，printDetails()这个操作被隐藏在了getOutStanding里，而这并不在我们重构的计划内。提取方法的重构目的，是用简明的方法调用来代替具体的代码块，提高原位置代码的可读性。如果将代码的方法调用看做是一个树状结构，提取方法就是在增加分支的深度。我们在读代码的时候，并不能看到下层方法的内容，所以将原本需要在上层直接读到的内容放在了很深的位置，反而会降低代码的可读性。 方法内联 Inline Method重构的一个重要目的是用简洁明了的方法名来替代代码原本所在的位置，以提高可读性。但有时会发现一些方法的内容已经简洁的跟方法名不相上下，这时就可以考虑舍弃方法了。 比如下面代码，moreThanFiveLateDeliveries和_numberOfLateDeliveries &gt; 5几乎没什么区别，也就没有必要留着方法了。 123456int getRating() { return (moreThanFiveLateDeliveries()) ? 2 : 1;}boolean moreThanFiveLateDeliveries(){ return _numberOfLateDeliveries &gt; 5;} 123int getRating() { return (_numberOfLateDeliveries &gt; 5)? 2 : 1;} 内联局部变量如果有一个局部变量像下面的basePrice一样只做了一次很简单的赋值操作，又没有被多个位置引用，那就没必要留着它了。 12double basePrice = anOrder.basePrice();return (basePrice &gt; 1000) 1return (anOrder.basePrice() &gt; 1000) 使用查找方法替代局部变量有时我们为了重复使用某一个表达式的结果，会将其保存在局部变量中，但是局部变量的访问有范围限制，想要使用该变量，就需要在同一个方法内，结果导致方法过长，过长的方法往往有着复杂的结构而又不好重构。如果使用查找方法来替代局部变量，便可以摆脱局部变量的范围限制，在类的各个地方都能使用表达式的结果，重构的时候也就少了很多顾虑。 12345double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000) return basePrice * 0.95;else return basePrice * 0.98; 将basePrice提取成为一个方法： 12345678if (basePrice() &gt; 1000) return basePrice() * 0.95;else return basePrice() * 0.98;...double basePrice() { return _quantity * _itemPrice;} 引入解释用变量比如下面代码 123456if ( (platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1)&amp;&amp; (browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1)&amp;&amp; wasInitialized() &amp;&amp; resize &gt; 0 ) { // do something } 条件语句的表达式非常复杂，难以理解，可以引入解释变量，提高条件语句的可读性： 1234567final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1;final boolean wasResized = resize &gt; 0;if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) { // do something} 不难发现，这个重构操作对条件语句的重构有很不错的效果，但是会引入新的局部变量。我们完全可以通过提取方法来简化表达式，所以作者也有提到：一般在无法提取方法时，才会想起来引入解释变量。有些方法由于使用了大量局部变量，使用提取方法来重构会很麻烦，这时引入解释变量可能有助于梳理算法结构，对进一步的重构有很大帮助。 分割局部变量我们可以这样理解:局部变量在方法中的作用大致有两种， 一种是在循环的处理中，用来当做index或者flag。 另一种是用来保存值或参照，方便多次的使用，这种局部变量应该只能被赋值一次。如果一个局部变量承担了超出上述范围的责任，就该考虑分割它了。让一个局部变量承担多种责任，会降低代码的可读性，造成混乱。所以遇到这种情况，尽可能一个变量一个责任的进行分割。分割之后，再考虑其他的重构操作。比如： 1234double temp = 2 * (_height + _width);System.out.println (temp);temp = _height * _width;System.out.println (temp); temp两次每调用时，保存的内容不一样，所以应该分割为两个变量： 1234final double perimeter = 2 * (_height + _width);System.out.println (perimeter);final double area = _height * _width;System.out.println (area); 移除对参数的赋值操作**参数可以引用，修改，但不可以直接使用 = 赋值 ** 123void aMethod(Object foo) {foo.modifyInSomeWay(); // √ 这个可以foo = anotherObject; // × 这个不行 首先要弄懂赋值的概念，使用=的操作，其作用不是修改变量的值，而是改变了该变量名所参照的对象。在方法中改变参数的参照（进行赋值操作），我的理解是有两个问题： 如果想通过方法的调用来改变参数的参照对象，可以通过返回值来进行赋值，直接在方法中使用=，调用方法的地方看不到该赋值操作，会降低代码的可读性。 如果是Pass By Value的编程语言，改变参数的参照（Reference），并不会影响到函数外的原变量。这就造成了混乱。 Pass By Value &amp;&amp; Pass By Reference复习一下值传递和引用传递 值传递 方法的参数是变量值的拷贝，在方法内修改参数值不会影响方法外变量的值 引用传递 方法的参数时变量的地址，在方法内修改参数会直接影响该内存地址的内容，方法外变量的值也会改变。 Java是值传递的编程语言，对于基本数据类型的值传递很好理解，对于引用类型的参数，java基本数据类型传递与引用传递区别 这篇文章里有个图很有助于理解 方法的代码如下 1234567891011121314151617181920package com.zejian.test;/** * java中的按值调用 * @author zejian */public class CallByValue { private static User user=null; public static void updateUser(User student){ student.setName(&quot;Lishen&quot;); student.setAge(18); } public static void main(String[] args) { user = new User(&quot;zhangsan&quot;,26); System.out.println(&quot;调用前user的值：&quot;+user.toString()); updateUser(user); System.out.println(&quot;调用后user的值：&quot;+user.toString()); }} 我们可以把引用类型的对象看作是一个值，引用类型的参数所传递的，是这个对象（图中的user），这就是引用类型的值传递。通过student调用对象的方法是可以修改user内容的，但如果使用=来对student进行赋值，只是让student指向了一个新的对象，并不会影响到user。为了防止参数赋值造成混乱，Java其实可以将参数设置为final，只不过好像没怎么见谁用过… 把方法换成对象如果一个方法中有太多的局部变量，以至于无法通过提取方法进行重构（可是不进行重构方法又太丑陋了），不妨把方法整体提取为一个独立的对象，局部变量变为该对象的属性后，就可以在对象内轻松地提取方法进行下一步的重构了。 书中例子： 12345678910Class Account int gamma (int inputVal, int quantity, int yearToDate) { int importantValue1 = (inputVal * quantity) + delta(); int importantValue2 = (inputVal * yearToDate) + 100; if ((yearToDate - importantValue1) &gt; 100) importantValue2 -= 20; int importantValue3 = importantValue2 * 7; // and so on. return importantValue3 - 2 * importantValue1; } 上面代码中，如果想要将计算返回值的部分提取出来，就需要将好多局部变量作为参数传递，非常复杂。我们可以使用对象来替代方法，首先写一个Gamma类： 12345678class Gamma... private final Account _account; private int inputVal; private int quantity; private int yearToDate; private int importantValue1; private int importantValue2; private int importantValue3; 再为Gamma类添加一个构造体： 123456Gamma (Account source, int inputValArg, int quantityArg, int yearToDateArg) { _account = source; // 为了使用方法delta() inputVal = inputValArg; quantity = quantityArg; yearToDate = yearToDateArg; } 然后将原方法的处理内容转移到Gamma中，作为一个待重构的方法： 123456789int compute () { importantValue1 = (inputVal * quantity) + _account.delta(); importantValue2 = (inputVal * yearToDate) + 100; if ((yearToDate - importantValue1) &gt; 100) importantValue2 -= 20; int importantValue3 = importantValue2 * 7; // and so on. return importantValue3 - 2 * importantValue1; } 这时，由于局部变量都已经变成了Gamma类的属性，我们提取方法时不需要再担心局部变量了： 12345678910111213int compute () { importantValue1 = (inputVal * quantity) + _account.delta(); importantValue2 = (inputVal * yearToDate) + 100; importantThing(); int importantValue3 = importantValue2 * 7; // and so on. return importantValue3 - 2 * importantValue1; } void importantThing() { if ((yearToDate - importantValue1) &gt; 100) importantValue2 -= 20; } 优化算法书中用的是substitue algorithm, 意思是用简明易懂的写法来替代旧算法，并没有追求提高算法效率或者降低消耗，我在理解的时候把这个重构操作也归类为优化 意思很简单：即使做的还是那些事儿，如果可以让你的算法看起来更容易理解，Just do it.","link":"/2019/04/24/2019-04-24-refactoring-C6/"},{"title":"关于枚举型的一些理解","text":"最近工作中写了一个枚举类，在code-review的时候被佐藤老师指摘了好几处，特别总结一下加深理解。 什么是枚举型 EnumEnum是Java 5开始引入的一个接口，关键字 enum 创建的类会自动使用Enum接口。 1234enum WeekDay { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY} 像这样定义了WeekDay之后，我们就不必为周一到周日创建整形或者字符串的静态变量了，可以直接把WeekDay中定义的七个名字当做基本型来使用: WeekDay.MONDAY , WeekDay.TUESDAY , WeekDay.WEDNESDAY , WeekDay.THURSDAY , WeekDay.FRIDAY , WeekDay.SATURDAY , WeekDay.SUNDAY 。 枚举型的构造体是私有的，不可以使用构造体来构建枚举类的实体，但是枚举类中的元素是公开的，可以像基本型一样直接取来使用。 1WorkDay day = WorkDat.SUNDAY; 用枚举类的思维方式来使用枚举类引入枚举类的一个主要目的，是可以有一种类型安全，不可变的方法来定义常量。在引入枚举类之前，一般通过定义基本型的常量来表达一些固定的值。比如 static final int MONDAY = 1; 这种写法看似没什么问题，可没有什么实际意义的1在这里承担了很重要的职责，不免让人产生疑问，改成0可不可以呢？而在判断是不是MONDAY时，又必须和1作比较，这就让程序逐渐变得复杂而又危险了。 引入枚举类之后，MONDAY本身就可以起到表达数值，作为判断条件的作用，从而减少了产生bug的可能性。所以，像下面这种强行使用枚举类的name toString来判断对象是否为枚举类中的一个元素的写法，是很不符合枚举类的思维方式的，浪费了使用枚举类的好处。 12345String a = System.getEnv(“TODAY”)；String today = &quot;Undefined&quot;;if(WeekDay.MONDAY.name.equals(a)){ today = WeekDay.MONDAY.name;} 我们可以给WeekDay添加一个方法来返回元素: 12345678public WeekDay as(String candidate){ if(MONDAY.name.equals(candidate)){ return MONDAY; }else if(...){ ... } return UNDEFINED; //添加一个未定义的元素} 这样我们在外面就可以告别那个中间的String，直接获取WeekDay的对象： 12345678WeekDay today = WeekDay.as(System.getEnv(&quot;TODAY&quot;));If(today == WeekDay.UNDEFINED){ // 对于未定义，空的设定值，或者默认值，可以在这里自由的设置}if(today == WeekDay.MONDAY){ // 想干啥干啥咯} 关联 [使用私有构造体或者枚举类型来强化单例性]","link":"/2019/07/17/2019-07-17-enum-things/"},{"title":"区分 Authentication(AuthN) 和 Authorization(AuthZ)","text":"最近写的一段代码里，关于关键字Auth的使用在review的时候被佐藤老师批评了，一直以来对于认证和授权都没有好好的理解，在这里整理一下。 别直接用Auth来命名之前对于Auth这个关键字的理解，一直都处于大概知道什么意思的模糊状态。其实使用Auth作为关键字来命名方法和变量，并不是很合适，因为Authentication 和 Authorization 的缩写都可以是Auth。 Authentication 的中文翻译是认证，日语翻译是認証，可以理解为判断你是不是谁的操作，比如输入用户名和密码，系统判断这个用户名存在，且密码匹配，就是认证。 Authorization 的中文翻译是授权，日语翻译是認可, 我的理解是你可不可以的意思，例如用户名密码通过认证之后，系统判断该用户是否有访问权限，给与权限的操作，就是授权。 401 和 403HTTP的返回值401和403是一对很容易弄混的数字。 401 Unauthorized 403 Forbidden 401是发生用户认证错误时的返回值，而403是拒绝访问。那么结合上面对Authentication和Authorization的理解不难发现: 401 虽然写着Unauthorized的名字，返回的却是Authentication的错误 403 则承担着返回Unauthorized错误的职责","link":"/2019/07/09/2019-07-09-AuthN-vs-AuthZ/"},{"title":"使用DB2的Docker镜像建立本地开发用的数据库","text":"这个是2019-07-23的笔记，DB2的社区免费版授权和镜像的使用方法随时可能改变。 从哪儿找DB2DB2的免费版本在 2019年的社区版DB2 中可以找到，提供了三种免费版的使用方法： 使用docker镜像 下载DB2程序 IBM Cloud的DB2服务（免费套餐） 这里记一下使用第一种方法Docker镜像的构建过程。 开工第一步，打开冰箱….啊不，下载镜像，可以在docker hub搜DB2，这篇笔记使用的是 ibmcom/db2第二步，创建容器，在控制台执行:1docker run --name db2 --privileged -p 50000:50000 -e LICENSE=accept -e DB2INST1_PASSWORD=password -e DBNAME=MYDATABASE ibmcom/db2 简单解释一下 --name 容器的名字，以后启动关闭的时候用 --privileged 不知道（弄懂了再写） -p 端口映射，这里的意思是本地的50000端口映射到容器的50000，这样我们就可以通过localhost:50000来访问容器里的数据库了 -e 给容器里设置一些环境变量 LICENSE 嗯。。。 DB2INST1_PASSWORD 为默认的用户名db2inst1设置的密码。 DBNAME 直接使用变量作为名字建立一个database 最后那个ibmcom/db2是镜像名 第三步，连接：1234url: jdbc:db2://localhost:50000/MYDATABASEusername: db2inst1password: passworddriver: db2jcc4.jar 驱动文件可以在IBM的服务网页找到 db2jcc4.jar 结束有时候会提示port无法使用，容器不能启动。先确定port50000没有被占用，如果可以使用，就重启docker。","link":"/2019/07/23/2019-07-23-docker-ibmdb2/"},{"title":"Dockerfile 命令","text":"内容整理自Docker入门到实践 什么是DockerfileDockerfile 是一种用来定制镜像的文本文件。我们可以在Dockerfile中指定基础镜像，执行命令，开放端口，设置环境变量等等。每一条指令会构建一层。参考docker 文档，docker的镜像具有下面的层结构(image layers)，增加层的厚度自然会增加镜像的大小，所以写Dockerfile时，尽量使用\\ 和 &amp;&amp; 巧妙地将命令的内容合并到一层。 比如Docker入门到实践中的例子，写一个构建nginx镜像的Dockerfile： 12FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 这个Dockerfile包含了两个指令，FROM制定了基础镜像，基础镜像可以是各种服务类的官方镜像，也可以是干净的操作系统镜像，还可以是空白镜像scratch。RUN是最常用的指令，用来执行命令行命令。 接下来我们执行 1docker build -t nginx:v3 . 来构建镜像，it nginx:v3的的意思是构建的目标名为nginx，标签为v3。 docker构建镜像的log将每一条指令分的很清楚，每一条指令作为一个step来执行，完成后我们就可以看到新的镜像nginx:v3了。 执行下面命令，通过新构建的镜像生成一个容器： 1docker run --name hello -d -p 8080:80 nginx:v3 然后我们访问 localhost:8080 就可以看到欢迎页了： Dockerfile中用到的命令docker的指令一般有两种书写方式，一种是指令后跟命令行，一种是使用[]的函数调用写法，这里主要记录一下命令行写法。 COPYCOPY &lt;context path&gt; &lt;target path&gt;这个指令将上下文目录中的文件或者目录复制到新一层的目标路径中，要复制的文件或者目录可以有多个，可以使用通配符（符合golang的filepath.Match规则)，目标路径可以是绝对路径，也可以是工作目录的相对路径。还可以加上--chown=&lt;user&gt;:&lt;group&gt;来改变文件的所属用户和所属组 上下文路径？context path? ADD使用方法跟COPY基本一样。功能会丰富一点，比如源路径可以设置为url，使用url路径时docker会讲文件打包下载到目标路径。因为需要多余的RUN来处理权限，解压缩，筛选内容，这个命令并不是很实用。 CMD用于指定默认的容器主进程的启动命令。指令的写法也有两种： shell 格式 CMD 命令 exec 格式 CMD [&quot;可执行文件&quot;, &quot;参数&quot;, ...&quot;参数&quot; ] 使用shell格式写的内容会被解析为CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;命令&quot;]，所以命令中可以使用环境变量，但是命令必须前台执行，如果命令结束后直接结束了sh程序，则容器也会推出。 Dockerfile中设置的启动命令可以在运行时重新指定，比如我们写docker run -it imagename的话，就会执行默认的命令，在镜像名后面添加命令，比如cat etc/os-release，就可以了。 ENTRYPOINT跟CMD一样用来设置启动时的命令行和参数，不过在重新定义的时候，要在docker run后面使用命令--entrypoint来设置。ENTRYPOINT和CMD共存的意义在于，定义了ENTRYPOINT之后，CMD的内容将不再被直接执行，而是作为参数传递给ENTRYPOINT。比如Docker入门-Dockerfile指令详解-NETRYPOINT入口点里面介绍的例子： 如果我们想在执行的时候为CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;https://ip.cn&quot; ]添加参数，直接在镜像名后面加肯定是不行的，那样会替换掉所有命令（全部重写那就另当别论了），如果使用CMD来获取参数，定义ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;https://ip.cn&quot; ]，就可以实现参数的自由设置了。 用ENTRYPOINT来处理CMD做不到的工作。 12345678FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ] docker-entrypoint.sh的内容为： 123456789#!/bin/sh...# allow the container to be started with `--user`if [ &quot;$1&quot; = 'redis-server' -a &quot;$(id -u)&quot; = '0' ]; then chown -R redis . exec su-exec redis &quot;$0&quot; &quot;$@&quot;fiexec &quot;$@&quot; 这里将cmd作为参数获取的方法，在ENTRYPOINT中设置了一个脚本，通过参数的内容来区别启动用户的身份。 ENV定义环境变量，就这么简单。可以用=，可以用空格，可以用等号加空格一行定义一群，也可以用\\加入换行。 ARG定义参数。参数和环境变量不同的是，参数只在构建的时候有用，在容器运行时不会被引入容器内部。参数的定义可以在docker build时使用--build-arg &lt;name&gt;=&lt;value&gt;的格式来覆盖。 VOLUME匿名卷 EXPOSE暴露端口 WORKDIR指定工作目录 USER指定当前用户 HEALTHCHECK健康检查 ONBUILD构建时执行 镜像的使用镜像的获取，管理和删除commit 命令","link":"/2019/07/30/2019-07-30-docker-instruction-commands/"},{"title":"HAS-A 和 IS-A的区别","text":"一句话总结不妨通过字面意思来理解，HAS-A 就是有什么的意思，而IS-A就是是什么的意思。在面向对象编程（OOP）中，类的继承就是IS-A的关系，简单来说就是“张三是个人，旺财是条狗”的意思。而类的对象使用，多数时候可以看作是HAS-A的关系，比如把身高，体重都看作是类的话，我们可以说“张三有身高，有体重”。 Inheritance 继承 IS-A composition 组成 HAS-A 举个栗子谷歌搜到的第一篇说明就很浅显易懂 123456789Class Car{ ... } // 车是一个类 Class Engine{ ... } // 引擎也是一个类Class Toyota extends Car { // 丰田车作为一个有继承关系的子类，跟Car是IS-A关系，跟Engine是HAS-A的关系 private Engine; ...}","link":"/2019/11/14/2019-11-14-has-a-and-is-a/"},{"title":"Concurrency - Java的并发编程","text":"Concurrency的意思是并发性，或者并行性（日语），顾名思义指的是同时处理不同的任务。并发编程的核心线程，可以简单地理解成RTS游戏里的“工人“单位:一个工人同一时间只能执行一个建造任务，增加工人可以增加建造序列的数量，也可以通过给工人切换建造任务来看起来增加建造序列，而这里的微操，全都是由系统来控制的。所以，并发编程并不针对多核CPU，即使只有一个CPU，也可以通过分时段的线程切换来实现多个线程的并发执行。 Java的基本多线程写法首先是线程的最基本写法。Java中有两种最基本的线程编写方法： 继承Thread类，在run()中书写程序内容，使用start()来启动线程。 123456789101112131415161718192021222324252627282930313233public class Sample{ public static void main(String... args) { WorkerA a = new WorkerA(); WorkerB b = new WorkerB(); // 这里我们有两个工人，可以同时启动两个建造任务了 a.start(); b.start(); }}class WorkerA extends Thread { /** * 在run里写上具体要给这个工人分配的任务 */ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.print(&quot;Yes, my lord. &quot; + i); } System.out.println(&quot;Building cpmolete.&quot;); }}class WorkerB extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.print(&quot;了解。&quot; + i); } System.out.println(&quot;任務完了。&quot;); }} 实现Runnable接口。Thread的构造体可以接受一个Runnable的参数，所以我们也可以通过写一个实现了Runnable接口的类来生成线程。虽然也是在run方法中写所要执行的任务，但是实现Runnable的类是作为生成线程的参数来使用，所以我们可以理解为创建了一类工作，然后以该工作为参数创建(灵魂召唤)多个工人来执行。 1234567891011121314151617181920212223 public class Sample { public static void main(String[] args) { // 我们创建了两个同样的工人，会执行同一种建造任务，比如都去造房子（卡人口不可取） Work work = new Work(); Thread workerA = new Thread(work); Thread workerB = new Thread(work); workerA.start(); workerB.start(); }}class Work implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.print(&quot;Yes, my lord. &quot; + i); } System.out.println(&quot;Building cpmolete.&quot;); }} Runnable也可以使用Lambda表达式来定义，这样我们就可以直接写run方法的内容而不用去定义一整个类了。 123456Thread c = new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { System.out.println(&quot;C &quot; + i); }});c.start(); 线程的状态和优先级java.lang的列举型Thread.State中定义了6中线程状态： 123456789101112131415161718192021222324/*** A Thread which has not yet started.*/NEW,/*** A Thread which is running or suspended.*/RUNNABLE,/*** A Thread which is blocked on a monitor.*/BLOCKED, /*** A Thread which is waiting with no timeout.*/WAITING,/*** A Thread which is waiting with a timeout.*/TIMED_WAITING, /*** A thread which is no longer alive.*/TERMINATED 一个线程只能由start()启动一次，多次启动会产生IllegalThreadStateException 在Thread类中定义了三个优先级常数： 123456789101112/** * The maximum priority value for a Thread. */public final static int MAX_PRIORITY = 10; // Maximum allowed priority for a thread/** * The minimum priority value for a Thread. */public final static int MIN_PRIORITY = 1; // Minimum allowed priority for a thread/** * The default priority value for a Thread. */public final static int NORM_PRIORITY = 5; // Normal priority for a thread 线程的优先级可以通过priority的getter和setter来设置和确认，当两个进行中的线程发生冲突时，一般优先级高的线程会先运行，但这并不等于说优先级高的线程一定会被优先启动。系统在启动线程的时候并不看优先级的高低。 Thread类Thread类提供了各种用来控制线程启动，暂停，再开，终止的方法，这里记录以下两个点的理解： InterruptedException. 当线程进入待机或者睡眠等状态时，就需要针对InterruptedException写一个try-catch，简单理解就是被人吵醒时应该怎么办。 sleep可以设置一定的时间，但并不等于时间到了线程就会停止挂起，继续运行。sleep只是线程在不被interrupt的情况下最短的睡眠时长，时间到了之后，也要视系统的资源分配情况来决定什么时候继续运行。 同步与排他并发编程一个很常见的问题就是不同线程对同一资源的读写控制，这里就要提到两个很基本的概念，同步和排他（锁）。排他锁比较好理解，就是通过关键字或者方法来指定某一部分同一时间只能被一个线程使用，被调用时这部分资源会被锁定，其他想要使用该资源的线程则会被挂起，知道资源解锁，轮班使用。synchronized是用来指定锁定资源的关键字，可以用来修饰方法，也可以用来指定代码块。 12345678public synchronized void add(int a){...}// 或者public void add(int a){ synchronized(想要锁定的对象){ //指定的对象在这段代码运行过程中被上锁 }} 同步则是指使用wait(),notify(),notifyAll()等方法，具体的控制线程的运行。wait()可以指定也可以不指定超时的值，wait可以让线程进入等待，直到等待超时或者其他的线程使用了notify(),notifyAll()或者interrupt()方法，使等待的线程进入可执行的状态。notify()会随机让一个等待的线程再开，notifyAll()则是让所有该对象的线程再开。wait(),notify(),notifyAll()都是用来控制线程访问被锁资源的，所以如果没有synchronized锁定资源，这些方法的会抛出IllegalMonitorStateException 排他锁无法避免会出现不同的线程锁定不同的资源大家都干不了活儿的局面，这就是死锁；或者因为要使用的资源不断被其他线程占用而导致某一线程进展缓慢，这叫活锁。死锁和活锁都不会在编译或者运行时报错，所以要留意设置超时，一定时间后手动解锁资源。等待资源访问时线程会处于饥饿的状态，饥饿的线程越多，则说明程序效率越低。为了减少饥饿，资源的调用顺序，锁定的粒度都需要好好思考。 并发集合高效的线程管理执行器线程池线程池的四种 BlockedQueue多线程中的问题内存释放 shutdown 和 shutdownNowInterruptException使用TimeUnit","link":"/2019/08/05/2019-08-05-concurrency/"},{"title":"Log4j 节能写法","text":"尽量使用Supplier&lt;&gt; 来生成log比如debug，我们可以使用下面三种方法 1234567891011121314151617181920212223242526/** * Logs a message object with the {@link Level#DEBUG DEBUG} level. * * @param message the message string to log. */void debug(String message);/** * Logs a message with parameters at the {@link Level#DEBUG DEBUG} level. * * @param message the message to log; the format depends on the message factory. * @param params parameters to the message. * @see #getMessageFactory() */void debug(String message, Object... params);/** * Logs a message with parameters which are only to be constructed if the logging level is the {@link Level#DEBUG * DEBUG} level. * * @param message the message to log; the format depends on the message factory. * @param paramSuppliers An array of functions, which when called, produce the desired log message parameters. * @since 2.4 */void debug(String message, Supplier&lt;?&gt;... paramSuppliers); 第一种：直接输出信息。最不环保的写法，甚至新手的话可能会出现logger.debug(&quot;A is &quot; + a + &quot;, B is&quot; + b + &quot;.&quot;);这种写法，首先使用+来生成log文本是非常耗时的，其次，无论log输出的级别是否低于debug，这段字符串的处理都会被执行。 第二种：使用MessageFactory和参数生成logOpenJDK 8之前这么写是没问题的，使用MessageFactory来生成log既增加了可读性，又比字符串连接要节能。不过问题是log的生成还是总需要被执行。 第三种：使用Lambdadoc中写了:only to be constructed if the logging level is the DEBUG level.，还需要解释吗？ 那么，当需要把objectA写到debug里时12345logger.debug(objectA.toString()); // 一般写法logger.debug(() -&gt; objectA.toString()); // 略动脑筋的写法logger.debug(objectA::toString); //文艺写法","link":"/2019/11/14/2019-11-14-log4j-using-lambda/"},{"title":"关于Java的stream执行顺序的笔记","text":"Java.util.stream 基本首先来个例子： 123Stream.of(&quot;aaa&quot;, &quot;aa&quot;, &quot;bbbb&quot;, &quot;bb&quot;, &quot;ccccc&quot;, &quot;cc&quot;, &quot;dddddd&quot;, &quot;eeeeeee&quot;) .filter(len -&gt; len.length() &gt; 3) .forEach(System.out::println); stream在使用的时候，分为中间操作（intermediate operation)和终端操作（terminal operation），例子中的filter()就是中间操作，中间操作可以有多个，跟火车厢一样接起来就可以。而终端操作（或者叫终结操作)只能有一个。终端操作很容易理解成是对stream的结束，事实上终端操作最主要的作用是执行。如果没有终端操作，中间操作的内容将不会生效。所以，下面这个stream执行后是什么效果？ 12345Stream.of(&quot;aaa&quot;, &quot;aa&quot;, &quot;bbbb&quot;, &quot;bb&quot;, &quot;ccccc&quot;, &quot;cc&quot;, &quot;dddddd&quot;, &quot;eeeeeee&quot;) .mapToInt(String::length) .filter(len -&gt; len &gt; 3) .peek(System.out::println) .limit(2); 答案是：什么也不输出。因为limit()是个中间方法，对这个stream的操作将不会生效。 执行顺序弄懂了什么中间操作和终端操作的区别以后，我们就要面对下一个疑问了：中间操作和终端操作的执行顺序是什么？很简单，来个例子瞧瞧： 123456Stream.of(&quot;aaa&quot;, &quot;aa&quot;, &quot;bbbb&quot;, &quot;bb&quot;, &quot;ccccc&quot;, &quot;cc&quot;, &quot;dddddd&quot;, &quot;eeeeeee&quot;) .filter(len -&gt; len.length() &gt; 3) .peek(System.out::println) .mapToInt(String::length) .limit(2) .forEach(System.out::println); 输出结果有几行？内容是? 这里重点在peek()，limit()和forEach()的生效顺序，从结果上来看,应该是stream中的每一个元素，对应一组打包的操作，所以输出字符串b之后紧接着输出的是b的长度，而不是字符串c。而limit()限制了处理的元素个数，大于limit的元素到达不了终端操作，自然不会生效。 我们换个方法再验证一遍，这次终端操作用sum()来替代forEach()，终端操作不是对元素逐一的操作了，对中间操作的执行顺序会有什么影响吗？ 1234567Stream.of(&quot;aaa&quot;, &quot;aa&quot;, &quot;bbbb&quot;, &quot;bb&quot;, &quot;ccccc&quot;, &quot;cc&quot;, &quot;dddddd&quot;, &quot;eeeeeee&quot;) .filter(len -&gt; len.length() &gt; 3) .peek(System.out::println) .mapToInt(String::length) .limit(2) .peek(System.out::println) .sum(); 结果跟forEach()是一样的。","link":"/2019/11/20/2019-11-20-about-java-stream-lazy/"},{"title":"使用Python的线性回归分析","text":"线性回归是啥？线性回归是统计学中的一种回归分析方法，我们可以简单的记住线性回归中有两个重要变量： The predictor(independent) variable 自变量 x the target(dependent) variable 因变量 y 如果线性回归方程中只有一个x，则称为简单线性回归，大于一个x时，成为多元线性回归。举个例子 1y = b0 + b1*x 这个简单线性回归方程中，x是自变量，y是因变量，b0是intercept, b1叫做slope Python中的简单线性回归1234567891011121314151617from sklearn.linear_model import LinearRegressionlm=LinearRegression()# 假设我们有一个dataframe dfX = df[['highway-mpg']] #作为自变量 X可以指定多列Y = df['Price'] #因变量Y只有一列lm.fit(X,Y) #使用线性回归分析Yhat = lm.predict(X_0) # X_0 跟X又相同的列数# 可以查看线性回归方程的参数lm.intercept_lm.coef_","link":"/2019/11/26/2019-11-26-linear-regression/"},{"title":"均方误差和决定系数","text":"均方误差 Mean Square Error是对误差的一个估计，其定义为所有估值和样本的误差平方的平均值。 在python中这样写： 1234from sklearn.metrics import mean_squared_errormean_sqlared_error(df['data'],predict) 决定系数 Coefficient of determination / $R^2$维基百科的定义是：用于度量因变量的变异中可由自变量解释部分所占的比例，以此来判断统计模型的解释力。 首先得到一组因变量 取得平均值 $\\bar{y}$ 由此可以得到总的方差 $SS_{tot}$ 再取得预估值的方差 $SS_{res}$ 最后得到决定系数 $R^2 = 1 - \\frac{SS_{tot}}{SS_{res}}$ 在python中这样写： 123456from sklearn.linear_model import LinearRegressionlm=LinearRegression()lm.score(X,Y)","link":"/2019/11/28/2019-11-28-measures-for-in-sample-evaluation/"},{"title":"pipenv 基本的介绍和使用方法","text":"根据项目需要，搞一个配置文件Pipfile，传到github里，完事儿。 为什么要用pipenv首先，我们假设….算了，不扯那些没用的。做Python的开发，无论你用的什么工具，最麻烦的事儿应该莫过于包的管理。pipenv简单来说就是一个python官方推荐的包管理工具。相比于pip等其他工具，pipenv最大的特点是可以根据项目，生成不同的环境，在ProjectA中设置的Pipfile不会影响到ProjectB,更不会影响到系统默认的pip列表。这个为项目定制的虚拟环境，我们称之为shell。 安装pipenv安装pipenv之前，首先确定系统里有以下两样东西： python pip pipenv是通过pip安装的工具，所以执行 1pip install pipenv 由于pipenv可以在系统里不同版本的Python间任意切换，所以执行pip的时候不同太在乎Python版本问题。 requirements.txt 和 Pipfilepipenv 管理Python环境的配置文件是Pipfile，大致长这个样子： 12345678910111213[[source]]name = &quot;pypi&quot;url = &quot;https://pypi.org/simple&quot;verify_ssl = true[dev-packages][packages]pandas = &quot;==0.25.1&quot;[requires]python_version = &quot;3.7&quot; 我们可以直接写，也可以用pipenv install来生成默认的Pipfile, 不过还有个更方便的方法是直接由pip生成的requirements.txt配置文件来生成Pipfile。 12345678# 首先在当前路径里使用pip生成requirements.txtpip freeze &gt; requirements.txt# 然后生成Pipfile# -r 的意思是将后面配置文件里的包添加到Pipfile里pipenv install -r requirements.txt 指定Python版本pipenv可以指定虚拟环境的python版本，随时通过修改Pipfile来切换（修改是通过命令行修改的意思，当然你要直接修改也没什么区别，但是不用命令来修改配置文件就会觉得很low啊） 12345678910## 使用下面的命令，从当前系统已经安装的不同版本的Python中选择一个pipenv --python 版本号## 比如pipenv --python 3.5pipenv --python 3.7pipenv --python 2.6 如果Pipfile中指定的Python版本在当前系统下不存在，之后启动虚拟环境时会跳出警告。 (耗时警报) 锁定更新Pipfile之后，启动虚拟环境之前，我们需要把Pipfile中列出的包安装好，或者删除已经不用的包，这个操作就是pipenv lock 由于需要从服务器下载相应的包（这是我猜的，鬼晓得为什么这玩意儿怎么那么慢，官方似乎也没有什么行之有效的办法） 去吧 皮卡丘！都搞定之后，pipenv shell跑起来，我们就进入定制的虚拟环境了。 直接看这里就可以了说了那么老多，其实安装好pipenv之后，直接一个pipenv -h查看help文档就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Options: --where Output project home information. --venv Output virtualenv information. --py Output Python interpreter information. --envs Output Environment Variable options. --rm Remove the virtualenv. --bare Minimal output. --completion Output completion (to be eval'd). --man Display manpage. --support Output diagnostic information for use in GitHub issues. --site-packages Enable site-packages for the virtualenv. [env var: PIPENV_SITE_PACKAGES] --python TEXT Specify which version of Python virtualenv should use. --three / --two Use Python 3/2 when creating virtualenv. --clear Clears caches (pipenv, pip, and pip-tools). [env var: PIPENV_CLEAR] -v, --verbose Verbose mode. --pypi-mirror TEXT Specify a PyPI mirror. --version Show the version and exit. -h, --help Show this message and exit.Usage Examples: Create a new project using Python 3.7, specifically: $ pipenv --python 3.7 Remove project virtualenv (inferred from current directory): $ pipenv --rm Install all dependencies for a project (including dev): $ pipenv install --dev Create a lockfile containing pre-releases: $ pipenv lock --pre Show a graph of your installed dependencies: $ pipenv graph Check your installed dependencies for security vulnerabilities: $ pipenv check Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e . Use a lower-level pip command: $ pipenv run pip freezeCommands: check Checks for security vulnerabilities and against PEP 508 markers provided in Pipfile. clean Uninstalls all packages not specified in Pipfile.lock. graph Displays currently-installed dependency graph information. install Installs provided packages and adds them to Pipfile, or (if no packages are given), installs all packages from Pipfile. lock Generates Pipfile.lock. open View a given module in your editor. run Spawns a command installed into the virtualenv. shell Spawns a shell within the virtualenv. sync Installs all packages specified in Pipfile.lock. uninstall Un-installs a provided package and removes it from Pipfile. update Runs lock, then sync.","link":"/2019/12/12/2019-12-12-pipenv-introduction/"},{"title":"CSS 文字对齐","text":"本来想直接把代码内嵌到markdown里，但是hexo好像不支持，残念 1234567891011121314151617181920&lt;table style=&quot;width:1000px&quot;&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;A&lt;/th&gt; &lt;th&gt;B&lt;/th&gt; &lt;th&gt;C&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th &gt;0&lt;/th&gt; &lt;td style=&quot;text-align: right;&quot;&gt;text-align: right;&lt;/td&gt; &lt;td style=&quot;text-align: left;&quot;&gt;text-align: left;&lt;/td&gt; &lt;td style=&quot;text-align: center;&quot;&gt;text-align: center;&lt;/td&gt; &lt;/tr&gt; &lt;tr style=&quot;height:100px;&quot;&gt; &lt;th&gt;1&lt;/th&gt; &lt;td style=&quot;vertical-align: top;&quot;&gt;vertical-align: top;&lt;/td&gt; &lt;td style=&quot;vertical-align: bottom;&quot;&gt;vertical-align: bottom;&lt;/td&gt; &lt;td style=&quot;vertical-align: middle;&quot;&gt;vertical-align: middle;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 水平方向对齐： text-align: right; text-align: center; text-align: left; 垂直方向对齐： vertical-align: top; vertical-align: middle; vertical-align: bottom;","link":"/2020/01/16/2020-01-16-css-vertical-align/"},{"title":"Git Prune命令","text":"git prune 简单地说就是一个清扫（housekeeping）的命令。 使用git查看分支，可以看到分支有三个重要分类：本地分支，本地-远程分支的参照，远程分支比如我们在github上merge了一个PR，顺手删除了一个分支，这时在本地的电脑上本删除的分支对应的本地分支，远程分支，远程本地的参照关系都还存在，如果我们使用git branch -D name删除该分支， 会发现只删除了本地的分支，所参照的远程分支origin/name依然存在，清理这种残留垃圾的命令的时候，就是用到了prune。 git remove prune 和 git fetch --prunegit remove prune 清理所有已经删掉的远程分支参照，但是不会删除本地分支 git fetch --prune 则是清理完远程的无用分支之后，再把最近状态fetch到本地","link":"/2020/01/24/2020-01-24-git-prune/"},{"title":"AngularJS 页面载入事件的相关方法","text":"AngularJS的uirouter一个重要的内容就是使用state的使用，这里记录一组关于state的事件，每当路由转移过程中发生对应事件时，都会在$rootScrope广播，使用$rootScope.$on('$stateEventName', function(event, ...))获取该事件。 0. 引入router.state.events首先引入JavaScript源文件： 1&lt;script src=&quot;stateEvents.js&quot;&gt;&lt;/script&gt; 然后导入模块： 1angular.module(&quot;myApplication&quot;, ['ui.router', 'ui.router.state.events'] 1. 事件 $stateChangeCancel $stateChangeStart $stateNotFound $stateChangeError $stateChangeSuccess $stateChangeCancel当一个页面的转移被取消时，会在$rootScope广播$stateChangeCancel事件有以下参数可以使用： toState 目标state toParams 前往目标state时的参数 fromState 来源state fromParams 带来的参数 options 选项 $transition$ 和开始事件$stateChangeStart ， 成功事件$stateChangeSuccess 提供的参数相同 $stateChangeError相比于开始和成功的事件，错误事件多一个参数error，其内容当然是错误信息。 $stateNotFound没有找到state时的事件，提供一下参数可以用： unfoudState 未找到的state信息，提供to toParams options等属性 fromState 来源state fromParams 来源参数 options 选项 2. 更新到 Transition Hooksuirouter已经更新了IHookRegistry接口，可以对transition进行更为详细控制。$transition 和$transitionService都实现了该接口，但是$transition对象只能在转换开始前使用。 该接口提供以下方法： getHooks 返回所有已登录的hook方法，参数时方法名，比如onBefore onEnter等等 onBefore 开始前 onStart 开始后 onExit 退出，onStart之后transition会推出state onRetain 保留，onExit之后onRetain会被执行，子state会被优先执行 onEnter 进入，在onRetain结束后，transition会进入state onFinish 结束前，这是最后可以取消或者定向transition的方法 onError 错误 onSuccess 成功","link":"/2020/01/21/2020-01-21-ng-state-event/"},{"title":"二进制大对象和字符大对象","text":"这都是啥啥啥 CLOB 和 BLOBCLOB 是可变长度的字符（char）大（long）对象（Object），用于基于字符的数据，以字节Byte或者标准八字节OCTET为单位，最大长度是2G（2,147,483,647） BLOB 是可变长度的二进制（Binary）大（long）对象（Object），用于保存语音，混合媒体等非传统数据，以字节Byte为单位，最大长度也是2G（2,147,483,647） OCTET 和 Byte我们都知道计算机中一个0/1表示一个比特bit,八个比特表示一个字节byte。但是在实际应用中，byte可以表示4-10比特的不同长度，为了统一标准，将严格意义上的8bits也称为OCTET","link":"/2020/01/28/2020-01-28-clob-octet/"},{"title":"Python中类的使用","text":"类就是Class 类的基本 类和实体 我们可以简单的将实体（instance）理解成具体的实物对象，把类看作是生产实体的蓝图。比如我们定义一个类Car，之后就可以在任何地方反复调用这个蓝图来生产Car的实体 方法 在Python中我们可以像写脚本一样随便写个方法就执行，但是这可能带来诸多麻烦。比如我们为汽车的启动和停止写了两个方法run()和stop()，为了确定让哪辆车启动哪辆车停下，我们需要把对象的车多为参数传递进方法，是不是有一种拿遥控器开车还要每次都设置开的哪辆车的感觉？ 当我们需要在不同的地方使用这两个方法时，就要重新写一遍。如果我们把run() 和stop()写到类Car里面，就可以通过每个Car的实体，直接调用启动和停止的方法，方法属于车的实体，不同实体间的启动停止互不影响，这就有开车那味儿了。 成员变量 类的成员变量分为两种(此处为Java思维）：静态变量和实例变量。 所谓静态变量，我们可以理解成刻在蓝图里的，比如我们给Car定义一个静态变量轮子数 = 4,这样我们生成的每个车都可以使用这个变量，甚至不生成实例的时候，也可以使用Car.轮子数, 只要看一下蓝图，就知道这个变量值。相比之下，实例变量就是指从属于实例的变量，比如排气量 长度 宽度,如果要调用这些变量，直接通过Car.排气量是不行的，因为图纸上可没具体写这变量是多少，需要先生成一个实体my_car = Car()，然后给my_car设置并使用 Python中类的使用类的定义Python中定义类使用的是关键字class，类的范围通过统一的缩进来管理 12345678910class Car: id = 12345 def __init__(self, id): self.id = id def run(self): print(f'run {self.id}!') 类的内部使用关键字def来定义方法，方法必须至少有一个参数self，self的含义相当于Java的this，指的是类的实例，可以通过self来访问实例变量和方法。 __init__是构造体，当我们使用类名来生成实例的时候，会根据参数来调用对应的构造体生成实例，最基本的写法就是直接通过构造体给实例变量初始化，比如使用上面代码里得构造体：Car(54321)。 Python中使用__双下划线来定义私有变量和私有方法，私有的元素无法在外部通过实例名或者类名访问到 就像Java中所有的类都是Object的字类，都继承了一些基本的方法一样，Python中也有一些类的专有方法, 且可以重写： init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 truediv: 除运算 mod: 求余运算 pow: 乘方 后记跟同事聊了聊为什么要使用类，想起了一个很重要的点：内存管理。如果我们不适用类来管理方法和变量的话，程序运行过程中，定义的变量和方法就会一直存在，占用内存空间；但是当我们使用了类之后，则可以在需要的时候声明类的实例来调用内存，当一个实例不再被使用的时候，又可以通过垃圾回收自动收回内存（垃圾回收机制不同语言有不同的做法）。这样我们的程序才可以根据需求灵活地使用资源。当然，方法和变量的管理更方便什么的，也算使用类的好处","link":"/2020/01/28/2020-01-28-python-class/"},{"title":"使用Java读写CSV文件","text":"最近针对一个Issue，需要给excel文件的读写功能增加CSV的支持，本来以为使用类似的方法可以直接写到DTO里面，结果一查，Java好像对CSV的支持还是最原始最基本的写法（并非贬义，可能是容易了反而不需要什么工具来读写CSV）。 总结成一句话就是，读写CSV就相当于读写一个纯字符串文件。 读取CSV读取CSV文件大致分为以下几步： 使用FileInputStream读取csv文件 使用BufferedReader来对输入流进行更高效的处理 将每一行的数据作为字符串读取，使用split(&quot;,&quot;)分割 123456789101112131415161718// 字符编码 设置下没坏处Charset charset = StandardCharsets.UTF_8;// 缓存大小 提高读取效率 int bufferSize = 5 * 1024 * 1024;try (BufferedReader reader = new BufferedReader( new InputStreamReader(new FileInputStream(&quot;input/sample.csv&quot;), charset), bufferSize)) { String line; List&lt;String[]&gt; data = new ArrayList&lt;&gt;(); // 这里假设文件不是很大，不然这么些内存是不够用的 while (Objects.nonNull(line = reader.readLine())) { data.add(line.split(&quot;,&quot;)); } // 然后 想怎么用就怎么用了} catch (IOException e) { // IOException 就囊括了读取文件可能发生的全部意外 e.printStackTrace();} 写CSV跟上面读取CSV的操作正好反过来，写CSV文件分为以下几步: 使用FileOutputStream输出文件 将要输出的一行数据使用指定的符号（csv一般是逗号）连接成字符串 输出到文件，使用BufferedWriter.write()的话记得换行 1234567891011121314151617// 文件路径和文件名String file = &quot;output/output.csv&quot;;// 指定字符编码Charset charset = StandardCharsets.UTF_8;// 指定缓存int bufferSize = 5 * 1024 * 1024;try (BufferedWriter writer = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(file), charset), bufferSize)) { for (String[] datum : data) { writer.write(String.join(&quot;,&quot;, datum)); // 换行 writer.newLine(); }} catch (IOException e) { e.printStackTrace();}","link":"/2020/02/06/2020-02-06-java-io-csv/"},{"title":"PlantUML（一） 类图","text":"ER图笔记（一） ER图 Entity Relationship Diagram Cardinality在线的端点通过下列符号来指定数量关系 123-- 1--|| 1 &amp;&amp; only 1--o| 0 or 1 123A-l-aB-||b C-o|c 123--{ multi--|{ 1 or more--o{ 0 or more 123D-{dE-|{eF-o{f Direction在线的中央插入下列关键字来指定方向 1234up, udown, d, doleft, l, leright, r, ri 12A-u-&gt;UpB-d-&gt;Down 12C-l-&gt;LeftD-r-&gt;Right package style可以使用自带的模版来定义每个包 123456789101112131415161718package foo1 &lt;&lt;Node&gt;&gt; { class Class1}package foo2 &lt;&lt;Rectangle&gt;&gt; { class Class2}package foo3 &lt;&lt;Folder&gt;&gt; { class Class3}package foo4 &lt;&lt;Frame&gt;&gt; { class Class4}package foo5 &lt;&lt;Cloud&gt;&gt; { class Class5}package foo6 &lt;&lt;Database&gt;&gt; { class Class6} 123456789101112131415161718package foo1 &lt;&lt;Node&gt;&gt; { class Class1}package foo2 &lt;&lt;Rectangle&gt;&gt; { class Class2}package foo3 &lt;&lt;Folder&gt;&gt; { class Class3}package foo4 &lt;&lt;Frame&gt;&gt; { class Class4}package foo5 &lt;&lt;Cloud&gt;&gt; { class Class5}package foo6 &lt;&lt;Database&gt;&gt; { class Class6}","link":"/2020/10/12/2020-10-12-er-1/"},{"title":"关于Enums的小问题","text":"原文链接 首先给出以下Enum： 12345enum Size{ SMALL, MEDIUM, LARGE} 问下面的代码执行的结果是： 123456public static void main(String[] args) { final var size = Size.SMALL; //line n1 switch (size) { //line n2 case SMALL: {System.out.println(size);} //line n3 }} n1处编译失败，初始化的写法错误 n2处编译失败，没对应把所有Size包含在case内 n3处编译失败，case后面应该是完整的Size.SMALL 输出 SMALL 输出 Size@3cb5cdba 分析选项1是错的，局部变量可以使用final来修饰，从Java 10开始，可以使用关键字var来声明局部变量，声明的变量类型由初始化的类型决定。选项2也是错的，switch-case从来都不需要面对所有情况写case。选项3也是错的，当switch的判断条件是enum类型时，case里不需要写类名。选项4是对的，enum类型默认重写了toString方法，输出name的值。选项5是错的，上面说了，enum的toString输出的是name，而不是HashCode.","link":"/2020/02/14/2020-02-14-oracle-quiz-enums/"},{"title":"实用Optional时需要注意的二三事","text":"使用了Optional为什么还发生NullPointerException对于空值应该怎么设置如何高效的实用Optional返回值如何避免Optional相关的反模式怎么把Optional用的更专业ReferenceThe Java Optianl class (12 recipes) The Java Optianl class (11 recipes)","link":"/2020/08/31/2020-08-31-java-optional-best-practice/"},{"title":"Day1 Python 基础","text":"1/100 【1】基本元素常见数据类型 整形 python3开始整数不区分int和long，支持二，八，十六进制。 浮点型 可以理解成小数 字符串 单引号 双引号都可以，三个引号输入多行内容 布尔型 True False 开头大写 变量名使用_连接 my_var_name_name_ 单下划线开头为受保护的实例属性__name__ 双下划线开头的为私有属性 使用 type() 来确认类型，使用下面的方法来转换类型： 12345int() #转换成整数 float() #转换成浮点数str() #转换成字符串，可以是字符编码chr() #字符串编码（整数）转换成字符串ord() #活的字符串对应的编码（整数） 【2】逻辑语句运算符除了常见的运算符外，python常用的还有： 12345is is notin not in if分支python的if分支跟函数，类一样都是使用缩进来表示代码的层次结构。 123456if name == 'a': print('a')elif name == 'b': print('b')else: print('c') 循环结构for-inpython一般使用for name in collection的方式来写循环语句 1234sum = 0for x in range(100): sum += xprint(sum) 【3】函数函数定义和参数定义函数的关键字是 def 12def foo(a): print(a) python中函数的参数可以设置默认值，所以使用的时候可以忽略部分参数或者直接指定某些参数，所以python的函数不需要像Java一样重载 12def add(a=0, b=0, c=0): return a + b + c 还可以定义可变参数来接收无法确定个数的参数： 123456def add(*args): total = 0 for val in args: total += val return total 模块python一个文件就算一个模块，通过import来导入指定模块的内容。 123# module1.pydef foo(): print('hello, world') 123# module2.pydef foo(): print('hello, world') 1234567# testimport module1 as m1import module2 as m2m1.foo()m2.foo() 还可以直接从模块导入具体的函数 123456from module1 import foofrom module2 import foo# 后导入的foo会覆盖之前导入的foo，所以这里使用的是module2的foofoo() name == ‘main‘模块中如果需要写入可执行语句，一般需要包装在 __name__ == '__main__' 中，这样除非直接运行该模块，这些可执行语句是不会被执行的 123456def foo(): print('hello, world')if __name__ == '__main__': foo() __name__ 是python的一个隐藏属性：模块名。 被python解释器直接执行的模块名字叫 __main__","link":"/2020/12/06/2020-12-06-day-1/"},{"title":"Day2 面向对象相关","text":"2/100 定义类python使用关键字class来定义类，在类名后的括号里写父类。 123456789101112131415161718class Student(object): # 相当于Java的构造体，类的field可以直接赋值，不用事先定义 def __init__(self, name, age): self.name = name self.age = age # 参数self相当于Java中的this，在调用方法的时候不需要指定，单如果没有这个参数就无法使用类的field def study(self, course): print(f'studing: {course}') def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: # 这是原作者 [jackfrued] 的爱好 print('%s正在观看岛国爱情大电影.' % self.name) 可见性 python并没有复杂而严格的可见性设置，虽然可以通过在方法和变量前加两个下划线来设置私有性，但这其实只是改变了访问规则而已。 12345678910111213141516171819202122232425class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo) # 在前面添加 _Test 就可以访问了 test._Test__bar() print(test._Test__foo)if __name__ == &quot;__main__&quot;: main() 一般使用单下划线来表明方法或变量是受保护的，但这也只是一种隐含的意思而已。 @property装饰器可以使用@property来包装属性，这样属性将会被封装起来，使用@property装饰的方法可以作为getter来使用，想要使用setter则需要@xxx.setter来修饰。 1234567891011121314151617181920212223242526272829303132333435363738394041class Person(object): def __init__(self, name, age): self._name = name¬ self._age = age¬ # 如果没有这个修饰，下面的person.name = 'Bob' 就不会报错 @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self.age &lt;= 16: print('plage game') else:¬ print('work')def main(): person = Person('Alcie', 12) person.play() person.age = 22 person.play() # AttributeError: can't set attribute person.name = 'Bob'if __name__ == '__main__': main()","link":"/2020/12/07/2020-12-07-day-2/"},{"title":"Day 3 面向对象进阶","text":"3/100 slotsPython是动态语言，我们可以随时为对象绑定新的属性和方法。但是如果我们想限制类型的对象所能绑定的属性，则需要用到__slots__。 123456789101112131415161718192021222324252627282930313233343536class Person(object): __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('play game') else: print('work')def main(): person = Person('Alice', 20) person.play() person._gender = 'male' # Error # person._family = Trueif __name__ == '__main__': main() 特殊方法 静态方法使用 @staticmethod 修饰 类方法使用 @classmethod 来修饰, 类方法的第一个参数必须是cls，表示当前类的对象","link":"/2020/12/07/2020-12-07-day-3/"},{"title":"Servlet 基础","text":"内容总结自网络。 定义Servlet(Server Applet) 可以翻译为Java小服务程序或者服务连接器。是用Java编写的服务器端程序，具有独立于平台和协议的特性。主要的功能是交互式地浏览和生成数据，生成动态Web内容。 狭义的Servlet是指Java的一个接口，广义的Servlet是指任何实现了这个接口的类。从原理上讲Servlet可以响应任何类型的请求，但绝大多数情况侠Servlet只用来扩展基于HTTP协议的Web服务器。 实现过程Servlet交互式地浏览和生成数据的过程为： 客户端发送请求到服务器 服务器将请求信息发送至Servlet Servlet生成响应内容并传给服务器。 服务器将响应返回客户端 生命周期 客户端请求Servlet 加载Servlet到内存 生成Servlet实例，调用init()初始化 server调用service()方法，将一个请求对象和一个响应对象传递给service() service()调用资源处理请求，使用响应对象的方法将响应传回server，再传回到客户端 (一般是server关闭时)调用destroy()方法","link":"/2021/04/20/2021-04-20-servlet-1/"},{"title":"web.xml 的Servlet配置","text":"web.xml中servlet配置及其含义 什么是 web.xmlweb.xml是Java工程中用来设置初始化配置信息的文件。xml的书写规则是有Schema文件来定义的。 web.xml使用的schema一般是Sun定义的，标注在标签&lt;web-app&gt;中。 web.xml中设置Servlet的常用标签【1】servlet123456789101112131415&lt;!-- servlet的配置 --&gt;&lt;servlet&gt; &lt;!-- 定义servlet的内部名称 --&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;!-- servlet的类名 此处为全路径--&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt; &lt;!-- 对应上面定义的servlet内部名称 --&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;!-- servlet的映射路径 --&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt;&lt;/servlet-maping&gt; 配置servlet标签需要配置两个，一个是servlet本身，另一个servlet-mapping是servlet的映射信息。servlet的servlet-name可以自定义，一般为servlet的类名，而servlet-class则是servlet类的全路径。servlet-mapping的servlet-name是对应的servlet名，url-pattern则是我们输入到浏览器地址栏中的用来调用servlet的url。 url-pattern 精确匹配 /servlet 模糊匹配 /* 模糊匹配 /path/* 模糊匹配 *.后缀 url-pattern除了上面的基本写法之外，还要注意几点： / 或者 *, url不能直接用servlet名开头。 同时使用两种模糊匹配是非法路径 匹配优先级：精确匹配最优先，后缀匹配最后 【2】初始参数可以设置两种参数用来初始化servlet，一种是init-param，一种时context-param。关于两种参数的区别：init-param and context-param init-param是给特定servlet设置的参数，所以写在&lt;servlet&gt;下面 12345678&lt;servlet&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;userName&lt;/param-name&gt; &lt;param-value&gt;Alice&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 使用的时候通过getServletConfig().getInitParamter(&quot;userName&quot;)来调用。 context-param是为webApp全局准备的参数，直接定义在&lt;web-app&gt;标签下，通过getServletContext().getInitParamter(&quot;userName&quot;)来调用 1234567&lt;web-app&gt; &lt;context-param&gt; &lt;param-name&gt;userName&lt;/param-name&gt; &lt;param-value&gt;Alice&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 【3】特殊标签 错误处理 1234567891011&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error404.jsp&lt;/location&gt; &lt;/error-page&gt; ...&lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;exception-type&gt; &lt;location&gt;/exception.jsp&lt;location&gt; &lt;/error-page&gt; 过滤器 12345678&lt;filter&gt; &lt;filter-name&gt; &lt;/filter-name&gt; &lt;filter-class&gt; &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt; &lt;/filter-name&gt; &lt;url-pattern&gt; &lt;/url-pattern&gt; &lt;/filter-mapping&gt; 监听器 123&lt;listener&gt; &lt;listener-class&gt;&lt;/listener-class&gt; &lt;/listener&gt; 会话 1234&lt;session-config&gt; &lt;!-- 以分为单位 --&gt; &lt;session-timeout&gt; &lt;/session-timeout&gt; &lt;/session-config&gt; 欢迎页 找不到index1，就会加载index2 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index1.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index2.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;","link":"/2021/04/22/2021-04-22-servlet-2-xml/"},{"title":"Mockito使い始めて見る","text":"Mockitoはクラスの偽のオブジェクトを作ってくれます。 when().thenReturn()を利用して、publicメソッドの戻る値を指定できます。 123456@Testpublic void add_with_when() { List&lt;String&gt; mockedList = mock(List.class); when(mockedList.size()).thenReturn(10); assertThat(mockedList.size(), is(10));} ここは1つ注意しなければならないことがあります。モックで作成したオブジェクトの全てのメソッドが偽物になります。下記のadd()はモックされたため、リストに追加する処理はありません。 1234567@Testpublic void add_without_when() { List&lt;String&gt; mockedList = mock(List.class); mockedList.add(&quot;A&quot;); mockedList.add(&quot;B&quot;); mockedList.add(&quot;C&quot;); assertThat(mockedList.size(), is(0)); Answers.CALL_REAL_METHODSを利用すれば、本物のメソッドを呼べます。 1234567891011121314@Testpublic void call_real_method() { Employee employee = mock(Employee.class, Answers.CALLS_REAL_METHODS); employee.setName(new Name(&quot;Alice&quot;)); assertThat(employee.getName(), is(&quot;Alice&quot;));}@Testpublic void call_real_method_with_when() { Employee employee = mock(Employee.class, Answers.CALLS_REAL_METHODS); employee.setName(new Name(&quot;Alice&quot;)); when(employee.getName()).thenReturn(new Name(&quot;Bob&quot;)); assertThat(employee.getName(), is(&quot;Bob&quot;));}","link":"/2021/07/21/2021-07-21-junit-1/"},{"title":"InjectMocksのインジェクト方法","text":"テスト対象のインスタンスに @InjectMocksをつけると、対象インスタンスのフィルドに@Mockされたインスタンスを差し込むことができる。 12345@InjectMocksManager manager;@MockName name; // manager.nameはモックされる 実現方法InjectMocksのJavadocを読むと、フィルドのinject方法は3つあります。 Constructor injection;1つ目はコンストラクターを利用してモックインスタンスを設定する。この方法はデフォルトで引数の数が一番多いコンストラクターを利用する。要注意なことは、必要なモックインスタンスが見つからない場合、その引数はnullとなる。引数にモックできないタイプ（基本型）がある場合、デフォルトのコンストラクターでInjectMocksのインスタンスを作って別の方法でInjectを実現する。 Property setter injection;2つ目はとてもわかりやすくて、フィルドのsetterメソッドを利用して、モックインスタンスを差し込む。該当のsetterメソッドを探すとき、まずフィルドのタイプを利用する。同じタイプのフィルドが存在する場合、モックインスタンスの名前を利用する。という理由で、モックインスタンスを定義するとき、できる限りInject対象のフィルドと同じ名前にする方がいい。Constructor Injectionでデフォルトコンストラクターを利用する場合、モックインスタンスの差し込むはこの方法で実現される。 Field injection;フィルドのsetterがない場合、直接設定でInjectを実現する。ルールはProperty setter injectionと同じ。","link":"/2021/08/04/2021-08-04-injectMocks/"},{"title":"JUnit5から使える @ParameterizedTest","text":"@ParameterizedTestは指定のテストメソッドに違う引数を順番に渡して処理することで、複数のテストを実現する方法。JUnit5の新しい機能として、使うとき以下のパッケージを依存関係に追加する必要がある。 1org.junit.jupiter:junit-jupiter-params 使ってみる@ParameterizedTestでパラメーター指定のテストケースを声明する。そして@ValueSourceを利用してパラメーターを指定する（整数:1,2,3）。 12345@ParameterizedTest@ValueSource(ints = {1, 2, 3})void test(int i) { System.out.println(i);} これで１つのメソッドでテストを3回実行した。@ParameterizedTestはorg.junit.jupiter.params.providerパッケージ下のインタフェースと一緒に使う必要がある。 DisplayName of ParameterizedTest@ParameterizedTestはパラメーターごとにテストケースを命名できる。 123456@ParameterizedTest(name = &quot;input is {0} {1} {2}&quot;)@CsvSource(value = {&quot;1,a,true&quot;})void test(int a, String b, boolean c) {} 使えるplaceholderは以下となる。 {index} テストケースの番号 {0~n} 指定番号の引数の値（0から） {arguments} 全ても引数 {displayName} @DisplayNameで指定する内容、@DisplayNameがない場合はテストメソッドの名前","link":"/2021/10/20/2021-10-20-parameterizedtest/"},{"title":"CLIでVue.jsを作る","text":"事前準備として、nodeをインストールする。 以下のコマンドを使って、バージョン確認する。 12node -vnpm -v バージョン古いときは以下のコマンドで更新できる。 1npm -g install npm 次のステップはvue-vliのインストール。 1npm install -g @vue/cli 2.x バージョンのvueは npm install -g vue-cliでインストールする 次はプロジェクトの親フォルダーへ移動して、プロジェクトを作る。 Webページのプロジェクトを作るため、以下のコマンドを実行する。 1vue init webpack myVueProject プロジェクト名などはディフォルで設定してくれるので、エンターキー連発でいい。router testなどの機能も初期化したい場合は、該当の確認で Y を入力すればいい。 これで、Vue.jsのプロジェクト作成完了。 最後は npm run buildでビルドして、 npm run devでサーバーを起動すればいい。","link":"/2021/11/17/2021-11-17-vue-step1/"},{"title":"Vue.js プロジェクトの構造","text":"Vue.jsプロジェクトファイルの構造とVueファイルの構造をメモする。 Vue.jsプロジェクトの構造 src components: 各モジュールはここで定義する main.js: 入り口のjs router index.js: ルーター設定 App.vue assets: 画像などのリソース index.html: 画面入り口 static: 静的リソース test config index.js: 各種設定 build package.json node_modules Vueファイルの構造Vueファイルは以下３つの部分がある。 [1]HTML 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; &lt;/div&gt;&lt;/template&gt; [2]JavaScript 12345678910&lt;script&gt;import HelloWorld from './components/HelloWorld.vue'export default { name: 'App', components: { HelloWorld }}&lt;/script&gt; [3]css 1234567891011&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt;","link":"/2021/11/12/2021-11-12-vue-project/"},{"title":"Python yeild","text":"123456789def myGenerator(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1for i in myGenerator(10): print(i) 带有yeild的函数就是generator。yeild每次被执行到，都会返回一个迭代值。下一次执行时从yeild所在的下一个语句继续执行。","link":"/2022/02/05/2022-02-05-yeild/"},{"title":"Mac 生成带密码的zip文件","text":"create a folder cd folderPath mkdir folderName create zip file and set password zip -er filename.zip folderPath input/confirm password","link":"/2022/02/06/2022-02-06-zip-pw/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/02/01/hello-world/"}],"tags":[{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"IntellJ IDEA","slug":"IntellJ-IDEA","link":"/tags/IntellJ-IDEA/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Bubik's Cube","slug":"Bubik-s-Cube","link":"/tags/Bubik-s-Cube/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"未填之坑","slug":"未填之坑","link":"/tags/%E6%9C%AA%E5%A1%AB%E4%B9%8B%E5%9D%91/"},{"name":"Ejs","slug":"Ejs","link":"/tags/Ejs/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"F-string","slug":"F-string","link":"/tags/F-string/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Gitpage","slug":"Gitpage","link":"/tags/Gitpage/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Refactoring","slug":"Refactoring","link":"/tags/Refactoring/"},{"name":"重构","slug":"重构","link":"/tags/%E9%87%8D%E6%9E%84/"},{"name":"Enum","slug":"Enum","link":"/tags/Enum/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"DB2","slug":"DB2","link":"/tags/DB2/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"stream","slug":"stream","link":"/tags/stream/"},{"name":"Data Analysis","slug":"Data-Analysis","link":"/tags/Data-Analysis/"},{"name":"Data Science","slug":"Data-Science","link":"/tags/Data-Science/"},{"name":"Pipenv","slug":"Pipenv","link":"/tags/Pipenv/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"CSV","slug":"CSV","link":"/tags/CSV/"},{"name":"PlantUML","slug":"PlantUML","link":"/tags/PlantUML/"},{"name":"Quiz Yourself","slug":"Quiz-Yourself","link":"/tags/Quiz-Yourself/"},{"name":"100 days of code","slug":"100-days-of-code","link":"/tags/100-days-of-code/"},{"name":"Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"Mockito","slug":"Mockito","link":"/tags/Mockito/"},{"name":"JUnit","slug":"JUnit","link":"/tags/JUnit/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"}],"categories":[]}