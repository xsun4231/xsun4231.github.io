{"title":"Python中类的使用","date":"2020-01-28T02:52:30.000Z","source":"_posts/2020-01-28-python-class.md","raw":"---\ntitle: Python中类的使用\ntags:\n  - Python\ndate: 2020-01-28 11:52:30\n---\n\n\n> 类就是Class\n\n## 类的基本\n\n1. 类和实体 我们可以简单的将实体（instance）理解成具体的实物对象，把类看作是生产实体的蓝图。比如我们定义一个类`Car`，之后就可以在任何地方反复调用这个蓝图来生产`Car`的实体\n2. 方法 在Python中我们可以像写脚本一样随便写个方法就执行，但是这可能带来诸多麻烦。比如我们为汽车的启动和停止写了两个方法`run()`和`stop()`，为了确定让哪辆车启动哪辆车停下，我们需要把对象的车多为参数传递进方法，是不是有一种拿遥控器开车还要每次都设置开的哪辆车的感觉？ 当我们需要在不同的地方使用这两个方法时，就要重新写一遍。如果我们把`run()` 和`stop()`写到类`Car`里面，就可以通过每个`Car`的实体，直接调用启动和停止的方法，方法属于车的实体，不同实体间的启动停止互不影响，这就有开车那味儿了。\n3. 成员变量 类的成员变量分为两种(此处为Java思维）：静态变量和实例变量。 所谓静态变量，我们可以理解成刻在蓝图里的，比如我们给`Car`定义一个静态变量`轮子数 = 4`,这样我们生成的每个车都可以使用这个变量，甚至不生成实例的时候，也可以使用`Car.轮子数`, 只要看一下蓝图，就知道这个变量值。相比之下，实例变量就是指从属于实例的变量，比如`排气量 长度 宽度`,如果要调用这些变量，直接通过`Car.排气量`是不行的，因为图纸上可没具体写这变量是多少，需要先生成一个实体`my_car = Car()`，然后给`my_car`设置并使用\n\n## Python中类的使用\n\n### 类的定义\nPython中定义类使用的是关键字`class`，类的范围通过统一的缩进来管理  \n```Python\nclass Car:\n  id = 12345\n\n\n  def __init__(self, id):\n    self.id = id\n\n\n  def run(self):\n    print(f'run {self.id}!')  \n```\n\n类的内部使用关键字`def`来定义方法，方法必须至少有一个参数`self`，`self`的含义相当于Java的`this`，指的是类的实例，可以通过`self`来访问实例变量和方法。  \n\n`__init__`是构造体，当我们使用类名来生成实例的时候，会根据参数来调用对应的构造体生成实例，最基本的写法就是直接通过构造体给实例变量初始化，比如使用上面代码里得构造体：`Car(54321)`。  \n\n\nPython中使用`__`双下划线来定义私有变量和私有方法，私有的元素无法在外部通过实例名或者类名访问到\n\n\n就像Java中所有的类都是Object的字类，都继承了一些基本的方法一样，Python中也有一些类的专有方法, 且可以重写：\n* __init__ : 构造函数，在生成对象时调用\n* __del__ : 析构函数，释放对象时使用\n* __repr__ : 打印，转换\n* __setitem__ : 按照索引赋值\n* __getitem__: 按照索引获取值\n* __len__: 获得长度\n* __cmp__: 比较运算\n* __call__: 函数调用\n* __add__: 加运算\n* __sub__: 减运算\n* __mul__: 乘运算\n* __truediv__: 除运算\n* __mod__: 求余运算\n* __pow__: 乘方\n\n## 后记\n跟同事聊了聊为什么要使用类，想起了一个很重要的点：内存管理。  \n如果我们不适用类来管理方法和变量的话，程序运行过程中，定义的变量和方法就会一直存在，占用内存空间；但是当我们使用了类之后，则可以在需要的时候声明类的实例来调用内存，当一个实例不再被使用的时候，又可以通过垃圾回收自动收回内存（垃圾回收机制不同语言有不同的做法）。这样我们的程序才可以根据需求灵活地使用资源。  \n当然，方法和变量的管理更方便什么的，也算使用类的好处","slug":"2020-01-28-python-class","published":true,"updated":"2025-01-31T15:39:12.959Z","_id":"cm6m2r3wv001lzg9d649v1ec3","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>类就是Class</p>\n</blockquote>\n<h2 id=\"类的基本\"><a href=\"#类的基本\" class=\"headerlink\" title=\"类的基本\"></a>类的基本</h2><ol>\n<li>类和实体 我们可以简单的将实体（instance）理解成具体的实物对象，把类看作是生产实体的蓝图。比如我们定义一个类<code>Car</code>，之后就可以在任何地方反复调用这个蓝图来生产<code>Car</code>的实体</li>\n<li>方法 在Python中我们可以像写脚本一样随便写个方法就执行，但是这可能带来诸多麻烦。比如我们为汽车的启动和停止写了两个方法<code>run()</code>和<code>stop()</code>，为了确定让哪辆车启动哪辆车停下，我们需要把对象的车多为参数传递进方法，是不是有一种拿遥控器开车还要每次都设置开的哪辆车的感觉？ 当我们需要在不同的地方使用这两个方法时，就要重新写一遍。如果我们把<code>run()</code> 和<code>stop()</code>写到类<code>Car</code>里面，就可以通过每个<code>Car</code>的实体，直接调用启动和停止的方法，方法属于车的实体，不同实体间的启动停止互不影响，这就有开车那味儿了。</li>\n<li>成员变量 类的成员变量分为两种(此处为Java思维）：静态变量和实例变量。 所谓静态变量，我们可以理解成刻在蓝图里的，比如我们给<code>Car</code>定义一个静态变量<code>轮子数 = 4</code>,这样我们生成的每个车都可以使用这个变量，甚至不生成实例的时候，也可以使用<code>Car.轮子数</code>, 只要看一下蓝图，就知道这个变量值。相比之下，实例变量就是指从属于实例的变量，比如<code>排气量 长度 宽度</code>,如果要调用这些变量，直接通过<code>Car.排气量</code>是不行的，因为图纸上可没具体写这变量是多少，需要先生成一个实体<code>my_car = Car()</code>，然后给<code>my_car</code>设置并使用</li>\n</ol>\n<h2 id=\"Python中类的使用\"><a href=\"#Python中类的使用\" class=\"headerlink\" title=\"Python中类的使用\"></a>Python中类的使用</h2><h3 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h3><p>Python中定义类使用的是关键字<code>class</code>，类的范围通过统一的缩进来管理  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span>:</span><br><span class=\"line\">  <span class=\"built_in\">id</span> = <span class=\"number\">12345</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">    <span class=\"variable language_\">self</span>.<span class=\"built_in\">id</span> = <span class=\"built_in\">id</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;run <span class=\"subst\">&#123;self.<span class=\"built_in\">id</span>&#125;</span>!&#x27;</span>)  </span><br></pre></td></tr></table></figure>\n\n<p>类的内部使用关键字<code>def</code>来定义方法，方法必须至少有一个参数<code>self</code>，<code>self</code>的含义相当于Java的<code>this</code>，指的是类的实例，可以通过<code>self</code>来访问实例变量和方法。  </p>\n<p><code>__init__</code>是构造体，当我们使用类名来生成实例的时候，会根据参数来调用对应的构造体生成实例，最基本的写法就是直接通过构造体给实例变量初始化，比如使用上面代码里得构造体：<code>Car(54321)</code>。  </p>\n<p>Python中使用<code>__</code>双下划线来定义私有变量和私有方法，私有的元素无法在外部通过实例名或者类名访问到</p>\n<p>就像Java中所有的类都是Object的字类，都继承了一些基本的方法一样，Python中也有一些类的专有方法, 且可以重写：</p>\n<ul>\n<li><strong>init</strong> : 构造函数，在生成对象时调用</li>\n<li><strong>del</strong> : 析构函数，释放对象时使用</li>\n<li><strong>repr</strong> : 打印，转换</li>\n<li><strong>setitem</strong> : 按照索引赋值</li>\n<li><strong>getitem</strong>: 按照索引获取值</li>\n<li><strong>len</strong>: 获得长度</li>\n<li><strong>cmp</strong>: 比较运算</li>\n<li><strong>call</strong>: 函数调用</li>\n<li><strong>add</strong>: 加运算</li>\n<li><strong>sub</strong>: 减运算</li>\n<li><strong>mul</strong>: 乘运算</li>\n<li><strong>truediv</strong>: 除运算</li>\n<li><strong>mod</strong>: 求余运算</li>\n<li><strong>pow</strong>: 乘方</li>\n</ul>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>跟同事聊了聊为什么要使用类，想起了一个很重要的点：内存管理。<br>如果我们不适用类来管理方法和变量的话，程序运行过程中，定义的变量和方法就会一直存在，占用内存空间；但是当我们使用了类之后，则可以在需要的时候声明类的实例来调用内存，当一个实例不再被使用的时候，又可以通过垃圾回收自动收回内存（垃圾回收机制不同语言有不同的做法）。这样我们的程序才可以根据需求灵活地使用资源。<br>当然，方法和变量的管理更方便什么的，也算使用类的好处</p>\n","excerpt":"","more":"<blockquote>\n<p>类就是Class</p>\n</blockquote>\n<h2 id=\"类的基本\"><a href=\"#类的基本\" class=\"headerlink\" title=\"类的基本\"></a>类的基本</h2><ol>\n<li>类和实体 我们可以简单的将实体（instance）理解成具体的实物对象，把类看作是生产实体的蓝图。比如我们定义一个类<code>Car</code>，之后就可以在任何地方反复调用这个蓝图来生产<code>Car</code>的实体</li>\n<li>方法 在Python中我们可以像写脚本一样随便写个方法就执行，但是这可能带来诸多麻烦。比如我们为汽车的启动和停止写了两个方法<code>run()</code>和<code>stop()</code>，为了确定让哪辆车启动哪辆车停下，我们需要把对象的车多为参数传递进方法，是不是有一种拿遥控器开车还要每次都设置开的哪辆车的感觉？ 当我们需要在不同的地方使用这两个方法时，就要重新写一遍。如果我们把<code>run()</code> 和<code>stop()</code>写到类<code>Car</code>里面，就可以通过每个<code>Car</code>的实体，直接调用启动和停止的方法，方法属于车的实体，不同实体间的启动停止互不影响，这就有开车那味儿了。</li>\n<li>成员变量 类的成员变量分为两种(此处为Java思维）：静态变量和实例变量。 所谓静态变量，我们可以理解成刻在蓝图里的，比如我们给<code>Car</code>定义一个静态变量<code>轮子数 = 4</code>,这样我们生成的每个车都可以使用这个变量，甚至不生成实例的时候，也可以使用<code>Car.轮子数</code>, 只要看一下蓝图，就知道这个变量值。相比之下，实例变量就是指从属于实例的变量，比如<code>排气量 长度 宽度</code>,如果要调用这些变量，直接通过<code>Car.排气量</code>是不行的，因为图纸上可没具体写这变量是多少，需要先生成一个实体<code>my_car = Car()</code>，然后给<code>my_car</code>设置并使用</li>\n</ol>\n<h2 id=\"Python中类的使用\"><a href=\"#Python中类的使用\" class=\"headerlink\" title=\"Python中类的使用\"></a>Python中类的使用</h2><h3 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h3><p>Python中定义类使用的是关键字<code>class</code>，类的范围通过统一的缩进来管理  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span>:</span><br><span class=\"line\">  <span class=\"built_in\">id</span> = <span class=\"number\">12345</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">    <span class=\"variable language_\">self</span>.<span class=\"built_in\">id</span> = <span class=\"built_in\">id</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;run <span class=\"subst\">&#123;self.<span class=\"built_in\">id</span>&#125;</span>!&#x27;</span>)  </span><br></pre></td></tr></table></figure>\n\n<p>类的内部使用关键字<code>def</code>来定义方法，方法必须至少有一个参数<code>self</code>，<code>self</code>的含义相当于Java的<code>this</code>，指的是类的实例，可以通过<code>self</code>来访问实例变量和方法。  </p>\n<p><code>__init__</code>是构造体，当我们使用类名来生成实例的时候，会根据参数来调用对应的构造体生成实例，最基本的写法就是直接通过构造体给实例变量初始化，比如使用上面代码里得构造体：<code>Car(54321)</code>。  </p>\n<p>Python中使用<code>__</code>双下划线来定义私有变量和私有方法，私有的元素无法在外部通过实例名或者类名访问到</p>\n<p>就像Java中所有的类都是Object的字类，都继承了一些基本的方法一样，Python中也有一些类的专有方法, 且可以重写：</p>\n<ul>\n<li><strong>init</strong> : 构造函数，在生成对象时调用</li>\n<li><strong>del</strong> : 析构函数，释放对象时使用</li>\n<li><strong>repr</strong> : 打印，转换</li>\n<li><strong>setitem</strong> : 按照索引赋值</li>\n<li><strong>getitem</strong>: 按照索引获取值</li>\n<li><strong>len</strong>: 获得长度</li>\n<li><strong>cmp</strong>: 比较运算</li>\n<li><strong>call</strong>: 函数调用</li>\n<li><strong>add</strong>: 加运算</li>\n<li><strong>sub</strong>: 减运算</li>\n<li><strong>mul</strong>: 乘运算</li>\n<li><strong>truediv</strong>: 除运算</li>\n<li><strong>mod</strong>: 求余运算</li>\n<li><strong>pow</strong>: 乘方</li>\n</ul>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>跟同事聊了聊为什么要使用类，想起了一个很重要的点：内存管理。<br>如果我们不适用类来管理方法和变量的话，程序运行过程中，定义的变量和方法就会一直存在，占用内存空间；但是当我们使用了类之后，则可以在需要的时候声明类的实例来调用内存，当一个实例不再被使用的时候，又可以通过垃圾回收自动收回内存（垃圾回收机制不同语言有不同的做法）。这样我们的程序才可以根据需求灵活地使用资源。<br>当然，方法和变量的管理更方便什么的，也算使用类的好处</p>\n","path":"2020/01/28/2020-01-28-python-class/","permalink":"https://xsun4231.github.io/2020/01/28/2020-01-28-python-class/","tags":[{"name":"Python","_id":"cm6m2r3wx001qzg9d4jbjg7nc","slug":"Python","path":"tags/Python/","permalink":"https://xsun4231.github.io/tags/Python/","length":4}],"categories":[],"prev":{"title":"二进制大对象和字符大对象","date":"2020-01-28T07:06:55.000Z","slug":"2020-01-28-clob-octet","published":true,"updated":"2025-01-31T15:39:12.949Z","_id":"cm6m2r3wv001jzg9d4q1z0iyf","layout":"post","photos":[],"excerpt":"","path":"2020/01/28/2020-01-28-clob-octet/","permalink":"https://xsun4231.github.io/2020/01/28/2020-01-28-clob-octet/","__post":true},"next":{"title":"Git Prune命令","date":"2020-01-24T05:45:42.000Z","slug":"2020-01-24-git-prune","published":true,"updated":"2025-01-31T15:39:12.949Z","_id":"cm6m2r3wu001ezg9ddujf2hu5","layout":"post","photos":[],"excerpt":"","path":"2020/01/24/2020-01-24-git-prune/","permalink":"https://xsun4231.github.io/2020/01/24/2020-01-24-git-prune/","__post":true},"__post":true}