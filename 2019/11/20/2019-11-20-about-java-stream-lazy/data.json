{"title":"关于Java的stream执行顺序的笔记","date":"2019-11-20T04:39:55.000Z","source":"_posts/2019-11-20-about-java-stream-lazy.md","raw":"---\ntitle: 关于Java的stream执行顺序的笔记\ntags:\n  - Java\n  - stream\ndate: 2019-11-20 13:39:55\n---\n\n## Java.util.stream 基本\n首先来个例子：\n```Java\nStream.of(\"aaa\", \"aa\", \"bbbb\", \"bb\", \"ccccc\", \"cc\", \"dddddd\", \"eeeeeee\")\n        .filter(len -> len.length() > 3)\n        .forEach(System.out::println);\n```\nstream在使用的时候，分为中间操作（intermediate operation)和终端操作（terminal operation），例子中的`filter()`就是中间操作，中间操作可以有多个，跟火车厢一样接起来就可以。\n而终端操作（或者叫终结操作)只能有一个。终端操作很容易理解成是对stream的结束，事实上终端操作最主要的作用是执行。如果没有终端操作，中间操作的内容将不会生效。所以，下面这个stream执行后是什么效果？\n```Java\nStream.of(\"aaa\", \"aa\", \"bbbb\", \"bb\", \"ccccc\", \"cc\", \"dddddd\", \"eeeeeee\")\n        .mapToInt(String::length)\n        .filter(len -> len > 3)\n        .peek(System.out::println)\n        .limit(2);\n```\n答案是：什么也不输出。因为`limit()`是个中间方法，对这个stream的操作将不会生效。  \n\n### 执行顺序\n弄懂了什么中间操作和终端操作的区别以后，我们就要面对下一个疑问了：中间操作和终端操作的执行顺序是什么？\n很简单，来个例子瞧瞧：\n```Java\nStream.of(\"aaa\", \"aa\", \"bbbb\", \"bb\", \"ccccc\", \"cc\", \"dddddd\", \"eeeeeee\")\n        .filter(len -> len.length() > 3)\n        .peek(System.out::println)\n        .mapToInt(String::length)\n        .limit(2)\n        .forEach(System.out::println);\n```\n输出结果有几行？内容是?\n\n{% asset_img 1.png result %}\n\n这里重点在`peek()`，`limit()`和`forEach()`的生效顺序，从结果上来看,应该是stream中的每一个元素，对应一组打包的操作，所以输出字符串b之后紧接着输出的是b的长度，而不是字符串c。而`limit()`限制了处理的元素个数，大于limit的元素到达不了终端操作，自然不会生效。\n\n我们换个方法再验证一遍，这次终端操作用`sum()`来替代`forEach()`，终端操作不是对元素逐一的操作了，对中间操作的执行顺序会有什么影响吗？\n```Java\nStream.of(\"aaa\", \"aa\", \"bbbb\", \"bb\", \"ccccc\", \"cc\", \"dddddd\", \"eeeeeee\")\n        .filter(len -> len.length() > 3)\n        .peek(System.out::println)\n        .mapToInt(String::length)\n        .limit(2)\n        .peek(System.out::println)\n        .sum();\n```\n结果跟`forEach()`是一样的。","slug":"2019-11-20-about-java-stream-lazy","published":true,"updated":"2025-01-31T15:39:12.949Z","_id":"cm6m2r3wt0016zg9d59xr4fwy","comments":true,"layout":"post","photos":[],"html":"<h2 id=\"Java-util-stream-基本\"><a href=\"#Java-util-stream-基本\" class=\"headerlink\" title=\"Java.util.stream 基本\"></a>Java.util.stream 基本</h2><p>首先来个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .filter(len -&gt; len.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>stream在使用的时候，分为中间操作（intermediate operation)和终端操作（terminal operation），例子中的<code>filter()</code>就是中间操作，中间操作可以有多个，跟火车厢一样接起来就可以。<br>而终端操作（或者叫终结操作)只能有一个。终端操作很容易理解成是对stream的结束，事实上终端操作最主要的作用是执行。如果没有终端操作，中间操作的内容将不会生效。所以，下面这个stream执行后是什么效果？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .mapToInt(String::length)</span><br><span class=\"line\">        .filter(len -&gt; len &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>答案是：什么也不输出。因为<code>limit()</code>是个中间方法，对这个stream的操作将不会生效。  </p>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>弄懂了什么中间操作和终端操作的区别以后，我们就要面对下一个疑问了：中间操作和终端操作的执行顺序是什么？<br>很简单，来个例子瞧瞧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .filter(len -&gt; len.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .mapToInt(String::length)</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>输出结果有几行？内容是?</p>\n\n\n<p>这里重点在<code>peek()</code>，<code>limit()</code>和<code>forEach()</code>的生效顺序，从结果上来看,应该是stream中的每一个元素，对应一组打包的操作，所以输出字符串b之后紧接着输出的是b的长度，而不是字符串c。而<code>limit()</code>限制了处理的元素个数，大于limit的元素到达不了终端操作，自然不会生效。</p>\n<p>我们换个方法再验证一遍，这次终端操作用<code>sum()</code>来替代<code>forEach()</code>，终端操作不是对元素逐一的操作了，对中间操作的执行顺序会有什么影响吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .filter(len -&gt; len.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .mapToInt(String::length)</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .sum();</span><br></pre></td></tr></table></figure>\n<p>结果跟<code>forEach()</code>是一样的。</p>\n","excerpt":"","more":"<h2 id=\"Java-util-stream-基本\"><a href=\"#Java-util-stream-基本\" class=\"headerlink\" title=\"Java.util.stream 基本\"></a>Java.util.stream 基本</h2><p>首先来个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .filter(len -&gt; len.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>stream在使用的时候，分为中间操作（intermediate operation)和终端操作（terminal operation），例子中的<code>filter()</code>就是中间操作，中间操作可以有多个，跟火车厢一样接起来就可以。<br>而终端操作（或者叫终结操作)只能有一个。终端操作很容易理解成是对stream的结束，事实上终端操作最主要的作用是执行。如果没有终端操作，中间操作的内容将不会生效。所以，下面这个stream执行后是什么效果？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .mapToInt(String::length)</span><br><span class=\"line\">        .filter(len -&gt; len &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>答案是：什么也不输出。因为<code>limit()</code>是个中间方法，对这个stream的操作将不会生效。  </p>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>弄懂了什么中间操作和终端操作的区别以后，我们就要面对下一个疑问了：中间操作和终端操作的执行顺序是什么？<br>很简单，来个例子瞧瞧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .filter(len -&gt; len.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .mapToInt(String::length)</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>输出结果有几行？内容是?</p>\n\n\n<p>这里重点在<code>peek()</code>，<code>limit()</code>和<code>forEach()</code>的生效顺序，从结果上来看,应该是stream中的每一个元素，对应一组打包的操作，所以输出字符串b之后紧接着输出的是b的长度，而不是字符串c。而<code>limit()</code>限制了处理的元素个数，大于limit的元素到达不了终端操作，自然不会生效。</p>\n<p>我们换个方法再验证一遍，这次终端操作用<code>sum()</code>来替代<code>forEach()</code>，终端操作不是对元素逐一的操作了，对中间操作的执行顺序会有什么影响吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;aa&quot;</span>, <span class=\"string\">&quot;bbbb&quot;</span>, <span class=\"string\">&quot;bb&quot;</span>, <span class=\"string\">&quot;ccccc&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;dddddd&quot;</span>, <span class=\"string\">&quot;eeeeeee&quot;</span>)</span><br><span class=\"line\">        .filter(len -&gt; len.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .mapToInt(String::length)</span><br><span class=\"line\">        .limit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        .peek(System.out::println)</span><br><span class=\"line\">        .sum();</span><br></pre></td></tr></table></figure>\n<p>结果跟<code>forEach()</code>是一样的。</p>\n","path":"2019/11/20/2019-11-20-about-java-stream-lazy/","permalink":"https://xsun4231.github.io/2019/11/20/2019-11-20-about-java-stream-lazy/","tags":[{"name":"Java","_id":"cm6m2r3wq000qzg9deq8b0ho7","slug":"Java","path":"tags/Java/","permalink":"https://xsun4231.github.io/tags/Java/","length":7},{"name":"stream","_id":"cm6m2r3x30030zg9d0hw3gtee","slug":"stream","path":"tags/stream/","permalink":"https://xsun4231.github.io/tags/stream/","length":1}],"categories":[],"prev":{"title":"使用Python的线性回归分析","date":"2019-11-26T02:32:56.000Z","slug":"2019-11-26-linear-regression","published":true,"updated":"2025-01-31T15:39:12.949Z","_id":"cm6m2r3wt0018zg9d6elxhfbl","layout":"post","photos":[],"excerpt":"","path":"2019/11/26/2019-11-26-linear-regression/","permalink":"https://xsun4231.github.io/2019/11/26/2019-11-26-linear-regression/","__post":true},"next":{"title":"Log4j 节能写法","date":"2019-11-14T08:06:39.000Z","slug":"2019-11-14-log4j-using-lambda","published":true,"updated":"2025-01-31T15:39:12.949Z","_id":"cm6m2r3ws0014zg9d0vs0a2vv","layout":"post","photos":[],"excerpt":"","path":"2019/11/14/2019-11-14-log4j-using-lambda/","permalink":"https://xsun4231.github.io/2019/11/14/2019-11-14-log4j-using-lambda/","__post":true},"__post":true}