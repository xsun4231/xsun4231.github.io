{"title":"关于枚举型的一些理解","date":"2019-07-16T23:39:22.000Z","source":"_posts/2019-07-17-enum-things.md","raw":"---\ntitle: 关于枚举型的一些理解\ntags:\n  - Enum\ndate: 2019-07-17 08:39:22\n---\n\n\n最近工作中写了一个枚举类，在code-review的时候被佐藤老师指摘了好几处，特别总结一下加深理解。\n  \n## 什么是枚举型 Enum\n\nEnum是Java 5开始引入的一个接口，关键字 `enum` 创建的类会自动使用Enum接口。  \n\n```Java\nenum WeekDay {\n    MONDAY, TUESDAY, WEDNESDAY,\n    THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}\n```\n\n像这样定义了`WeekDay`之后，我们就不必为周一到周日创建整形或者字符串的静态变量了，可以直接把`WeekDay`中定义的七个名字当做基本型来使用: `WeekDay.MONDAY` , `WeekDay.TUESDAY` , `WeekDay.WEDNESDAY` ,  `WeekDay.THURSDAY` ,  `WeekDay.FRIDAY` ,  `WeekDay.SATURDAY` ,  `WeekDay.SUNDAY` 。 \n\n枚举型的构造体是私有的，不可以使用构造体来构建枚举类的实体，但是枚举类中的元素是公开的，可以像基本型一样直接取来使用。\n```Java\nWorkDay day = WorkDat.SUNDAY; \n```\n\n## 用枚举类的思维方式来使用枚举类\n引入枚举类的一个主要目的，是可以有一种类型安全，不可变的方法来定义常量。在引入枚举类之前，一般通过定义基本型的常量来表达一些固定的值。\n比如` static final int MONDAY = 1;` 这种写法看似没什么问题，可没有什么实际意义的`1`在这里承担了很重要的职责，不免让人产生疑问，改成`0`可不可以呢？\n而在判断是不是`MONDAY`时，又必须和`1`作比较，这就让程序逐渐变得复杂而又危险了。\n\n引入枚举类之后，MONDAY本身就可以起到表达数值，作为判断条件的作用，从而减少了产生bug的可能性。  \n所以，像下面这种强行使用枚举类的`name` `toString`来判断对象是否为枚举类中的一个元素的写法，是很不符合枚举类的思维方式的，浪费了使用枚举类的好处。\n```Java\nString a = System.getEnv(“TODAY”)；\nString today = \"Undefined\";\nif(WeekDay.MONDAY.name.equals(a)){\n  today = WeekDay.MONDAY.name;\n} \n```\n\n我们可以给`WeekDay`添加一个方法来返回元素:\n```Java\npublic WeekDay as(String candidate){\n  if(MONDAY.name.equals(candidate)){\n    return MONDAY;\n  }else if(...){\n    ...\n  }\n  return UNDEFINED; //添加一个未定义的元素\n}\n```\n\n这样我们在外面就可以告别那个中间的String，直接获取WeekDay的对象：\n```Java\nWeekDay today = WeekDay.as(System.getEnv(\"TODAY\"));\nIf(today == WeekDay.UNDEFINED){\n  // 对于未定义，空的设定值，或者默认值，可以在这里自由的设置\n}\n\nif(today == WeekDay.MONDAY){\n  // 想干啥干啥咯\n}\n```\n\n## 关联 [使用私有构造体或者枚举类型来强化单例性]\n","slug":"2019-07-17-enum-things","published":true,"updated":"2025-01-31T15:39:12.845Z","_id":"cm6m2r3wq000tzg9d0xk10ey7","comments":true,"layout":"post","photos":[],"html":"<p>最近工作中写了一个枚举类，在code-review的时候被佐藤老师指摘了好几处，特别总结一下加深理解。</p>\n<h2 id=\"什么是枚举型-Enum\"><a href=\"#什么是枚举型-Enum\" class=\"headerlink\" title=\"什么是枚举型 Enum\"></a>什么是枚举型 Enum</h2><p>Enum是Java 5开始引入的一个接口，关键字 <code>enum</code> 创建的类会自动使用Enum接口。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">WeekDay</span> &#123;</span><br><span class=\"line\">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class=\"line\">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像这样定义了<code>WeekDay</code>之后，我们就不必为周一到周日创建整形或者字符串的静态变量了，可以直接把<code>WeekDay</code>中定义的七个名字当做基本型来使用: <code>WeekDay.MONDAY</code> , <code>WeekDay.TUESDAY</code> , <code>WeekDay.WEDNESDAY</code> ,  <code>WeekDay.THURSDAY</code> ,  <code>WeekDay.FRIDAY</code> ,  <code>WeekDay.SATURDAY</code> ,  <code>WeekDay.SUNDAY</code> 。 </p>\n<p>枚举型的构造体是私有的，不可以使用构造体来构建枚举类的实体，但是枚举类中的元素是公开的，可以像基本型一样直接取来使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WorkDay</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> WorkDat.SUNDAY; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用枚举类的思维方式来使用枚举类\"><a href=\"#用枚举类的思维方式来使用枚举类\" class=\"headerlink\" title=\"用枚举类的思维方式来使用枚举类\"></a>用枚举类的思维方式来使用枚举类</h2><p>引入枚举类的一个主要目的，是可以有一种类型安全，不可变的方法来定义常量。在引入枚举类之前，一般通过定义基本型的常量来表达一些固定的值。<br>比如<code> static final int MONDAY = 1;</code> 这种写法看似没什么问题，可没有什么实际意义的<code>1</code>在这里承担了很重要的职责，不免让人产生疑问，改成<code>0</code>可不可以呢？<br>而在判断是不是<code>MONDAY</code>时，又必须和<code>1</code>作比较，这就让程序逐渐变得复杂而又危险了。</p>\n<p>引入枚举类之后，MONDAY本身就可以起到表达数值，作为判断条件的作用，从而减少了产生bug的可能性。<br>所以，像下面这种强行使用枚举类的<code>name</code> <code>toString</code>来判断对象是否为枚举类中的一个元素的写法，是很不符合枚举类的思维方式的，浪费了使用枚举类的好处。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> System.getEnv(“TODAY”)；</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">today</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Undefined&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(WeekDay.MONDAY.name.equals(a))&#123;</span><br><span class=\"line\">  today = WeekDay.MONDAY.name;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>我们可以给<code>WeekDay</code>添加一个方法来返回元素:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> WeekDay <span class=\"title function_\">as</span><span class=\"params\">(String candidate)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(MONDAY.name.equals(candidate))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MONDAY;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> UNDEFINED; <span class=\"comment\">//添加一个未定义的元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们在外面就可以告别那个中间的String，直接获取WeekDay的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WeekDay</span> <span class=\"variable\">today</span> <span class=\"operator\">=</span> WeekDay.as(System.getEnv(<span class=\"string\">&quot;TODAY&quot;</span>));</span><br><span class=\"line\">If(today == WeekDay.UNDEFINED)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对于未定义，空的设定值，或者默认值，可以在这里自由的设置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(today == WeekDay.MONDAY)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 想干啥干啥咯</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关联-使用私有构造体或者枚举类型来强化单例性\"><a href=\"#关联-使用私有构造体或者枚举类型来强化单例性\" class=\"headerlink\" title=\"关联 [使用私有构造体或者枚举类型来强化单例性]\"></a>关联 [使用私有构造体或者枚举类型来强化单例性]</h2>","excerpt":"","more":"<p>最近工作中写了一个枚举类，在code-review的时候被佐藤老师指摘了好几处，特别总结一下加深理解。</p>\n<h2 id=\"什么是枚举型-Enum\"><a href=\"#什么是枚举型-Enum\" class=\"headerlink\" title=\"什么是枚举型 Enum\"></a>什么是枚举型 Enum</h2><p>Enum是Java 5开始引入的一个接口，关键字 <code>enum</code> 创建的类会自动使用Enum接口。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">WeekDay</span> &#123;</span><br><span class=\"line\">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class=\"line\">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>像这样定义了<code>WeekDay</code>之后，我们就不必为周一到周日创建整形或者字符串的静态变量了，可以直接把<code>WeekDay</code>中定义的七个名字当做基本型来使用: <code>WeekDay.MONDAY</code> , <code>WeekDay.TUESDAY</code> , <code>WeekDay.WEDNESDAY</code> ,  <code>WeekDay.THURSDAY</code> ,  <code>WeekDay.FRIDAY</code> ,  <code>WeekDay.SATURDAY</code> ,  <code>WeekDay.SUNDAY</code> 。 </p>\n<p>枚举型的构造体是私有的，不可以使用构造体来构建枚举类的实体，但是枚举类中的元素是公开的，可以像基本型一样直接取来使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WorkDay</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> WorkDat.SUNDAY; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用枚举类的思维方式来使用枚举类\"><a href=\"#用枚举类的思维方式来使用枚举类\" class=\"headerlink\" title=\"用枚举类的思维方式来使用枚举类\"></a>用枚举类的思维方式来使用枚举类</h2><p>引入枚举类的一个主要目的，是可以有一种类型安全，不可变的方法来定义常量。在引入枚举类之前，一般通过定义基本型的常量来表达一些固定的值。<br>比如<code> static final int MONDAY = 1;</code> 这种写法看似没什么问题，可没有什么实际意义的<code>1</code>在这里承担了很重要的职责，不免让人产生疑问，改成<code>0</code>可不可以呢？<br>而在判断是不是<code>MONDAY</code>时，又必须和<code>1</code>作比较，这就让程序逐渐变得复杂而又危险了。</p>\n<p>引入枚举类之后，MONDAY本身就可以起到表达数值，作为判断条件的作用，从而减少了产生bug的可能性。<br>所以，像下面这种强行使用枚举类的<code>name</code> <code>toString</code>来判断对象是否为枚举类中的一个元素的写法，是很不符合枚举类的思维方式的，浪费了使用枚举类的好处。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> System.getEnv(“TODAY”)；</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">today</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Undefined&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(WeekDay.MONDAY.name.equals(a))&#123;</span><br><span class=\"line\">  today = WeekDay.MONDAY.name;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>我们可以给<code>WeekDay</code>添加一个方法来返回元素:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> WeekDay <span class=\"title function_\">as</span><span class=\"params\">(String candidate)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(MONDAY.name.equals(candidate))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MONDAY;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(...)&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> UNDEFINED; <span class=\"comment\">//添加一个未定义的元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们在外面就可以告别那个中间的String，直接获取WeekDay的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WeekDay</span> <span class=\"variable\">today</span> <span class=\"operator\">=</span> WeekDay.as(System.getEnv(<span class=\"string\">&quot;TODAY&quot;</span>));</span><br><span class=\"line\">If(today == WeekDay.UNDEFINED)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对于未定义，空的设定值，或者默认值，可以在这里自由的设置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(today == WeekDay.MONDAY)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 想干啥干啥咯</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关联-使用私有构造体或者枚举类型来强化单例性\"><a href=\"#关联-使用私有构造体或者枚举类型来强化单例性\" class=\"headerlink\" title=\"关联 [使用私有构造体或者枚举类型来强化单例性]\"></a>关联 [使用私有构造体或者枚举类型来强化单例性]</h2>","path":"2019/07/17/2019-07-17-enum-things/","permalink":"https://xsun4231.github.io/2019/07/17/2019-07-17-enum-things/","tags":[{"name":"Enum","_id":"cm6m2r3x2002nzg9dersb1hsx","slug":"Enum","path":"tags/Enum/","permalink":"https://xsun4231.github.io/tags/Enum/","length":1}],"categories":[],"prev":{"title":"使用DB2的Docker镜像建立本地开发用的数据库","date":"2019-07-23T05:36:40.000Z","slug":"2019-07-23-docker-ibmdb2","published":true,"updated":"2025-01-31T15:39:12.845Z","_id":"cm6m2r3wr000xzg9ddz5y7e20","layout":"post","photos":[],"excerpt":"","path":"2019/07/23/2019-07-23-docker-ibmdb2/","permalink":"https://xsun4231.github.io/2019/07/23/2019-07-23-docker-ibmdb2/","__post":true},"next":{"title":"区分 Authentication(AuthN) 和 Authorization(AuthZ)","date":"2019-07-09T02:48:48.000Z","slug":"2019-07-09-AuthN-vs-AuthZ","published":true,"updated":"2025-01-31T15:39:12.845Z","_id":"cm6m2r3wq000uzg9d1qul3ko2","layout":"post","photos":[],"excerpt":"","path":"2019/07/09/2019-07-09-AuthN-vs-AuthZ/","permalink":"https://xsun4231.github.io/2019/07/09/2019-07-09-AuthN-vs-AuthZ/","__post":true},"__post":true}