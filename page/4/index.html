<!DOCTYPE html><html lang="zh-CN" theme="default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="XSUN"><title>XSUN's blog</title><meta name="description" content="A simple and beautiful blog"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta id="site_data_static" data-url="/"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/js_complied/bundle.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet"><script src="/js_complied/bundle.js"></script><script>Anatolo.comment.setConfig({"valine":{"enable":false,"appid":null,"appkey":null,"notify":false,"verify":false,"avatar":"mm","placeholder":"hello, world"},"gitment":{"enable":false,"owner":"Your GitHub ID","repo":"Repo to store comments","client_id":"Your client ID","client_secret":"Your client secret"},"gitalk":{"enable":false,"owner":"Your GitHub ID","repo":"Repo to store comments","client_id":"Your client ID","client_secret":"Your client secret"},"duoshuo":null,"disqus":null,"gentie":null})</script><meta name="generator" content="Hexo 7.3.0"></head><body> <main-outlet><div class="page-top animated"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="nav_right_btn"><li class="btn-toggle-more"><i class="fa fa-ellipsis"></i></li><li class="btn-search"><a class="fa fa-search" onclick="Anatolo.search.openWindow();"></a></li><li class="btn-toggle-theme"><a class="far fa-sun" onclick="Anatolo.darkLightToggle();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">XSUN's blog</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Null-PE"><i class="fab fa-github"></i></a></li></ul></div></div><div class="footer"><div class="p"><span>Author </span><i class="fa fa-star"></i><span> XSUN</span></div><div class="by_farbox"><span>Powered by</span><a href="https://hexo.io/zh-cn/" target="_blank"> Hexo</a><span> &</span><a href="https://github.com/Lhcfl/hexo-theme-anatolo" target="_blank"> Anatolo</a></div><div class="beian"></div></div></div><div class="main animated fadeInDown"><div class="autopagerize_page_element"><div class="content"><div class="post animated"><div class="post-title"><h3><a href="/2019/07/23/2019-07-23-docker-ibmdb2/">使用DB2的Docker镜像建立本地开发用的数据库</a></h3></div><div class="post-content"><div class="card"><p><p>这个是2019-07-23的笔记，DB2的社区免费版授权和镜像的使用方法随时可能改变。</p>
<h2 id="从哪儿找DB2"><a href="#从哪儿找DB2" class="headerlink" title="从哪儿找DB2"></a>从哪儿找DB2</h2><p>DB2的免费版本在 <a target="_blank" rel="noopener" href="https://www.ibm.com/cloud/blog/announcements/ibm-db2-developer-community-edition">2019年的社区版DB2</a> 中可以找到，提供了三种免费版的使用方法：</p>
<ol>
<li>使用docker镜像</li>
<li>下载DB2程序</li>
<li>IBM Cloud的DB2服务（免费套餐）</li>
</ol>
<p>这里记一下使用第一种方法Docker镜像的构建过程。</p>
<h2 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h2><h3 id="第一步，打开冰箱…-啊不，下载镜像，可以在docker-hub搜DB2，这篇笔记使用的是-ibmcom-db2"><a href="#第一步，打开冰箱…-啊不，下载镜像，可以在docker-hub搜DB2，这篇笔记使用的是-ibmcom-db2" class="headerlink" title="第一步，打开冰箱….啊不，下载镜像，可以在docker hub搜DB2，这篇笔记使用的是 ibmcom&#x2F;db2"></a>第一步，打开冰箱….啊不，下载镜像，可以在docker hub搜DB2，这篇笔记使用的是 <a target="_blank" rel="noopener" href="https://hub.docker.com/r/ibmcom/db2">ibmcom&#x2F;db2</a></h3><h3 id="第二步，创建容器，在控制台执行"><a href="#第二步，创建容器，在控制台执行" class="headerlink" title="第二步，创建容器，在控制台执行:"></a>第二步，创建容器，在控制台执行:</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name db2 --privileged -p 50000:50000 -e LICENSE=accept -e DB2INST1_PASSWORD=password -e DBNAME=MYDATABASE ibmcom/db2</span></span><br></pre></td></tr></table></figure>

<p>简单解释一下</p>
<ol>
<li><code>--name</code> 容器的名字，以后启动关闭的时候用 </li>
<li><code>--privileged</code> 不知道（弄懂了再写）</li>
<li><code>-p</code> 端口映射，这里的意思是本地的50000端口映射到容器的50000，这样我们就可以通过<code>localhost:50000</code>来访问容器里的数据库了</li>
<li><code>-e</code> 给容器里设置一些环境变量<ol>
<li><code>LICENSE</code> 嗯。。。</li>
<li><code>DB2INST1_PASSWORD</code> 为默认的用户名db2inst1设置的密码。</li>
<li><code>DBNAME</code> 直接使用变量作为名字建立一个database</li>
</ol>
</li>
<li>最后那个<code>ibmcom/db2</code>是镜像名</li>
</ol>
<h3 id="第三步，连接："><a href="#第三步，连接：" class="headerlink" title="第三步，连接："></a>第三步，连接：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: jdbc:db2://localhost:50000/MYDATABASE</span><br><span class="line">username: db2inst1</span><br><span class="line">password: password</span><br><span class="line">driver: db2jcc4.jar </span><br></pre></td></tr></table></figure>
<p>驱动文件可以在IBM的服务网页找到 <a target="_blank" rel="noopener" href="http://www-01.ibm.com/support/docview.wss?uid=swg21363866">db2jcc4.jar</a></p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>有时候会提示port无法使用，容器不能启动。先确定port50000没有被占用，如果可以使用，就重启docker。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-23</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Docker/" title="Docker">Docker </a><i class="fa fa-tag"></i><a class="tag" href="/tags/DB2/" title="DB2">DB2 </a><span>大约406个字, 1分钟21秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/07/17/2019-07-17-enum-things/">关于枚举型的一些理解</a></h3></div><div class="post-content"><div class="card"><p><p>最近工作中写了一个枚举类，在code-review的时候被佐藤老师指摘了好几处，特别总结一下加深理解。</p>
<h2 id="什么是枚举型-Enum"><a href="#什么是枚举型-Enum" class="headerlink" title="什么是枚举型 Enum"></a>什么是枚举型 Enum</h2><p>Enum是Java 5开始引入的一个接口，关键字 <code>enum</code> 创建的类会自动使用Enum接口。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WeekDay</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这样定义了<code>WeekDay</code>之后，我们就不必为周一到周日创建整形或者字符串的静态变量了，可以直接把<code>WeekDay</code>中定义的七个名字当做基本型来使用: <code>WeekDay.MONDAY</code> , <code>WeekDay.TUESDAY</code> , <code>WeekDay.WEDNESDAY</code> ,  <code>WeekDay.THURSDAY</code> ,  <code>WeekDay.FRIDAY</code> ,  <code>WeekDay.SATURDAY</code> ,  <code>WeekDay.SUNDAY</code> 。 </p>
<p>枚举型的构造体是私有的，不可以使用构造体来构建枚举类的实体，但是枚举类中的元素是公开的，可以像基本型一样直接取来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WorkDay</span> <span class="variable">day</span> <span class="operator">=</span> WorkDat.SUNDAY; </span><br></pre></td></tr></table></figure>

<h2 id="用枚举类的思维方式来使用枚举类"><a href="#用枚举类的思维方式来使用枚举类" class="headerlink" title="用枚举类的思维方式来使用枚举类"></a>用枚举类的思维方式来使用枚举类</h2><p>引入枚举类的一个主要目的，是可以有一种类型安全，不可变的方法来定义常量。在引入枚举类之前，一般通过定义基本型的常量来表达一些固定的值。<br>比如<code> static final int MONDAY = 1;</code> 这种写法看似没什么问题，可没有什么实际意义的<code>1</code>在这里承担了很重要的职责，不免让人产生疑问，改成<code>0</code>可不可以呢？<br>而在判断是不是<code>MONDAY</code>时，又必须和<code>1</code>作比较，这就让程序逐渐变得复杂而又危险了。</p>
<p>引入枚举类之后，MONDAY本身就可以起到表达数值，作为判断条件的作用，从而减少了产生bug的可能性。<br>所以，像下面这种强行使用枚举类的<code>name</code> <code>toString</code>来判断对象是否为枚举类中的一个元素的写法，是很不符合枚举类的思维方式的，浪费了使用枚举类的好处。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> System.getEnv(“TODAY”)；</span><br><span class="line"><span class="type">String</span> <span class="variable">today</span> <span class="operator">=</span> <span class="string">&quot;Undefined&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(WeekDay.MONDAY.name.equals(a))&#123;</span><br><span class="line">  today = WeekDay.MONDAY.name;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们可以给<code>WeekDay</code>添加一个方法来返回元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> WeekDay <span class="title function_">as</span><span class="params">(String candidate)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(MONDAY.name.equals(candidate))&#123;</span><br><span class="line">    <span class="keyword">return</span> MONDAY;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> UNDEFINED; <span class="comment">//添加一个未定义的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在外面就可以告别那个中间的String，直接获取WeekDay的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeekDay</span> <span class="variable">today</span> <span class="operator">=</span> WeekDay.as(System.getEnv(<span class="string">&quot;TODAY&quot;</span>));</span><br><span class="line">If(today == WeekDay.UNDEFINED)&#123;</span><br><span class="line">  <span class="comment">// 对于未定义，空的设定值，或者默认值，可以在这里自由的设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(today == WeekDay.MONDAY)&#123;</span><br><span class="line">  <span class="comment">// 想干啥干啥咯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关联-使用私有构造体或者枚举类型来强化单例性"><a href="#关联-使用私有构造体或者枚举类型来强化单例性" class="headerlink" title="关联 [使用私有构造体或者枚举类型来强化单例性]"></a>关联 [使用私有构造体或者枚举类型来强化单例性]</h2></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Enum/" title="Enum">Enum </a><span>大约675个字, 2分钟15秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/07/09/2019-07-09-AuthN-vs-AuthZ/">区分 Authentication(AuthN) 和 Authorization(AuthZ)</a></h3></div><div class="post-content"><div class="card"><p><p>最近写的一段代码里，关于关键字<code>Auth</code>的使用在review的时候被佐藤老师批评了，一直以来对于认证和授权都没有好好的理解，在这里整理一下。</p>
<h2 id="别直接用Auth来命名"><a href="#别直接用Auth来命名" class="headerlink" title="别直接用Auth来命名"></a>别直接用Auth来命名</h2><p>之前对于<code>Auth</code>这个关键字的理解，一直都处于大概知道什么意思的模糊状态。其实使用<code>Auth</code>作为关键字来命名方法和变量，并不是很合适，因为<code>Authentication</code> 和 <code>Authorization</code> 的缩写都可以是<code>Auth</code>。  </p>
<p><code>Authentication</code> 的中文翻译是<code>认证</code>，日语翻译是<code>認証</code>，可以理解为判断<strong>你是不是谁</strong>的操作，比如输入用户名和密码，系统判断这个用户名存在，且密码匹配，就是认证。</p>
<p><code>Authorization</code> 的中文翻译是<code>授权</code>，日语翻译是<code>認可</code>, 我的理解是<strong>你可不可以</strong>的意思，例如用户名密码通过认证之后，系统判断该用户是否有访问权限，给与权限的操作，就是授权。</p>
<h2 id="401-和-403"><a href="#401-和-403" class="headerlink" title="401 和 403"></a>401 和 403</h2><p>HTTP的返回值401和403是一对很容易弄混的数字。</p>
<ul>
<li>401 Unauthorized</li>
<li>403 Forbidden</li>
</ul>
<p>401是发生用户认证错误时的返回值，而403是拒绝访问。那么结合上面对<code>Authentication</code>和<code>Authorization</code>的理解不难发现:</p>
<ul>
<li>401 虽然写着Unauthorized的名字，返回的却是Authentication的错误</li>
<li>403 则承担着返回Unauthorized错误的职责</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-09</span><span>大约373个字, 1分钟14秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/04/24/2019-04-24-refactoring-C6/">代码重构 - 改善方法的结构</a></h3></div><div class="post-content"><div class="card"><p><p>代码重构做的最多的就是改善方法的结构。去掉方法中不需要的元素，修改不明确的名称，将复杂而冗长的方法改成精简而明确的小方法群组，是重构方法的主要思路。  </p>
<p>方法重构用的最多的是【提取方法】，有种将一地零落的玩具分类整理装箱的感觉；而【方法内联】一般在方法提取的过于详细以至于产生了反作用，或者需要重新整理方法间关系时使用。  </p>
<p>【提取方法】的最大问题，是如何处理局部变量，这就用到了对局部变量的重构技巧。  </p>
<h2 id="提取方法-Extract-Method"><a href="#提取方法-Extract-Method" class="headerlink" title="提取方法 Extract Method"></a>提取方法 Extract Method</h2><p>如果发现方法内有一个代码块在很具体的做一件事儿，或者有一句漂亮的注释解释了接下来好几行的操作，那就试试把它提取成一个方法吧，然后取个足以说明其作用的方法名。比如：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    printBanner();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print details</span></span><br><span class="line">    System.out.println (<span class="string">&quot;name:&quot;</span> + _name);</span><br><span class="line">    System.out.println (<span class="string">&quot;amount&quot;</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构后是这个样子：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    printBanner();</span><br><span class="line">    printDetails(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span> <span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    System.out.println (<span class="string">&quot;name:&quot;</span> + _name);</span><br><span class="line">    System.out.println (<span class="string">&quot;amount&quot;</span> + amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漂亮的代码往往方法都很简短，有着意思明确的方法名。方法越简洁，被重复利用的机会就越大；方法名如果足以传达信息，又可以省去不少的注释。<br>方法的简洁程度和方法名的好坏是联系在一起的，提取方法可以看做是用方法名来取代原位置的代码块，如果不能通过方法名理解原本代码块要执行的操作，重构也就失去了意义。<br>重构的时候不用刻意去思考方法或者方法名的长度，重构的关键在于方法名和代码块之间的语义距离（semantic distance)。</p>
<h3 id="局部变量的处理"><a href="#局部变量的处理" class="headerlink" title="局部变量的处理"></a>局部变量的处理</h3><p>如果要提取的代码块使用了局部变量，提取方法的操作就要变得稍微复杂一些了。<br>首先我们需要观察一下局部变量定义、赋值以及被调用的位置，如果局部变量相关的代码可以移动位置，不妨先优化一下，因为优化前后，接下来的重构操作可能会有很大不同。</p>
<ol>
<li>如果局部变量足够“局部”，可以直接放到新方法内部，当然是最简单的情况。  </li>
<li>如果局部变量的赋值是在新方法的处理范围外，新方法只是调用了变量值而没有进行修改，我们可以把局部变量当做参数传达给新的方法。  </li>
<li>如果需要新方法的处理来给变量赋值，而变量值的使用又在新方法的范围外，则需要为新方法添加返回值，返回变量值。</li>
</ol>
<blockquote>
<p>想返回多个变量值咋整嘞？这里涉及到了[单一返回值]的问题。编程语言普遍使用的是单一返回值的方法结构，这样可以保证代码的可读性，避免混乱。如果遇到了需要返回多个值的情况，不妨试着细化方法的划分，使用多个单一返回值的方法来实现。</p>
</blockquote>
<p>栗子，重构下面代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Enumeration</span> <span class="variable">e</span> <span class="operator">=</span> _orders.elements();</span><br><span class="line">    <span class="type">double</span> <span class="variable">outstanding</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    printBanner();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate outstanding</span></span><br><span class="line">    <span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">each</span> <span class="operator">=</span> (Order) e.nextElement();</span><br><span class="line">        outstanding += each.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printDetails(outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中直接进行了如下的重构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">    printBanner();</span><br><span class="line">    <span class="type">double</span> <span class="variable">outstanding</span> <span class="operator">=</span> getOutstanding();</span><br><span class="line">    printDetails(outstanding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">getOutstanding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Enumeration</span> <span class="variable">e</span> <span class="operator">=</span> _orders.elements();</span><br><span class="line">    <span class="type">double</span> <span class="variable">outstanding</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">each</span> <span class="operator">=</span> (Order) e.nextElement();</span><br><span class="line">        outstanding += each.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outstanding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中说将<code>outstanding</code>的计算提取成了一个独立的方法，而前面的局部变量因为只在计算中被使用到，所以一并提取了出来。这里有一个看似理所当然却值得做笔记的操作：作者并没有将<code>printBanner()</code>或者<code>printDetails()</code>放在新方法内。<br>如果将<code>pringDetails()</code>放到<code>getOutstanding()</code>里，不就不需要设返回值了？ 这是因为重构的对象是计算<code>outstanding</code>的代码块，如果将不相关的方法一并放到新方法内，就偏离了重构的目的。<br>假设将<code>printDetails()</code>放在了<code>getOutstanding()</code>内，再看<code>printOwing()</code>会发现，可以获取的信息变少了，<code>printDetails()</code>这个操作被隐藏在了<code>getOutStanding</code>里，而这并不在我们重构的计划内。<br>提取方法的重构目的，是用简明的方法调用来代替具体的代码块，提高原位置代码的可读性。如果将代码的方法调用看做是一个树状结构，提取方法就是在增加分支的深度。我们在读代码的时候，并不能看到下层方法的内容，所以将原本需要在上层直接读到的内容放在了很深的位置，反而会降低代码的可读性。</p>
<h2 id="方法内联-Inline-Method"><a href="#方法内联-Inline-Method" class="headerlink" title="方法内联 Inline Method"></a>方法内联 Inline Method</h2><p>重构的一个重要目的是用简洁明了的方法名来替代代码原本所在的位置，以提高可读性。但有时会发现一些方法的内容已经简洁的跟方法名不相上下，这时就可以考虑舍弃方法了。  </p>
<p>比如下面代码，<code>moreThanFiveLateDeliveries</code>和<code>_numberOfLateDeliveries &gt; 5</code>几乎没什么区别，也就没有必要留着方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getRating</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (moreThanFiveLateDeliveries()) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">moreThanFiveLateDeliveries</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getRating</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (_numberOfLateDeliveries &gt; <span class="number">5</span>)? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内联局部变量"><a href="#内联局部变量" class="headerlink" title="内联局部变量"></a>内联局部变量</h2><p>如果有一个局部变量像下面的<code>basePrice</code>一样只做了一次很简单的赋值操作，又没有被多个位置引用，那就没必要留着它了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">basePrice</span> <span class="operator">=</span> anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> (basePrice &gt; <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (anOrder.basePrice() &gt; <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用查找方法替代局部变量"><a href="#使用查找方法替代局部变量" class="headerlink" title="使用查找方法替代局部变量"></a>使用查找方法替代局部变量</h2><p>有时我们为了重复使用某一个表达式的结果，会将其保存在局部变量中，但是局部变量的访问有范围限制，想要使用该变量，就需要在同一个方法内，结果导致方法过长，过长的方法往往有着复杂的结构而又不好重构。如果使用查找方法来替代局部变量，便可以摆脱局部变量的范围限制，在类的各个地方都能使用表达式的结果，重构的时候也就少了很多顾虑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">basePrice</span> <span class="operator">=</span> _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br></pre></td></tr></table></figure>
<p>将<code>basePrice</code>提取成为一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> <span class="title function_">basePrice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引入解释用变量"><a href="#引入解释用变量" class="headerlink" title="引入解释用变量"></a>引入解释用变量</h2><p>比如下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (platform.toUpperCase().indexOf(<span class="string">&quot;MAC&quot;</span>) &gt; -<span class="number">1</span>)&amp;&amp;</span><br><span class="line">      (browser.toUpperCase().indexOf(<span class="string">&quot;IE&quot;</span>) &gt; -<span class="number">1</span>)&amp;&amp;</span><br><span class="line">       wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>条件语句的表达式非常复杂，难以理解，可以引入解释变量，提高条件语句的可读性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isMacOs</span>     <span class="operator">=</span> platform.toUpperCase().indexOf(<span class="string">&quot;MAC&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isIEBrowser</span> <span class="operator">=</span> browser.toUpperCase().indexOf(<span class="string">&quot;IE&quot;</span>)  &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wasResized</span>  <span class="operator">=</span> resize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现，这个重构操作对条件语句的重构有很不错的效果，但是会引入新的局部变量。我们完全可以通过提取方法来简化表达式，所以作者也有提到：一般在无法提取方法时，才会想起来引入解释变量。<br>有些方法由于使用了大量局部变量，使用提取方法来重构会很麻烦，这时引入解释变量可能有助于梳理算法结构，对进一步的重构有很大帮助。</p>
<h2 id="分割局部变量"><a href="#分割局部变量" class="headerlink" title="分割局部变量"></a>分割局部变量</h2><p>我们可以这样理解:局部变量在方法中的作用大致有两种，</p>
<ol>
<li>一种是在循环的处理中，用来当做index或者flag。</li>
<li>另一种是用来保存值或参照，方便多次的使用，这种局部变量应该只能被赋值一次。<br>如果一个局部变量承担了超出上述范围的责任，就该考虑分割它了。让一个局部变量承担多种责任，会降低代码的可读性，造成混乱。所以遇到这种情况，尽可能一个变量一个责任的进行分割。分割之后，再考虑其他的重构操作。比如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println (temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println (temp);</span><br></pre></td></tr></table></figure>

<p><code>temp</code>两次每调用时，保存的内容不一样，所以应该分割为两个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println (perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> _height * _width;</span><br><span class="line">System.out.println (area);</span><br></pre></td></tr></table></figure>

<h2 id="移除对参数的赋值操作"><a href="#移除对参数的赋值操作" class="headerlink" title="移除对参数的赋值操作"></a>移除对参数的赋值操作</h2><p>**参数可以引用，修改，但不可以直接使用 <code>=</code> 赋值 **   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">aMethod</span><span class="params">(Object foo)</span> &#123;</span><br><span class="line">foo.modifyInSomeWay();           <span class="comment">// √ 这个可以</span></span><br><span class="line">foo = anotherObject;             <span class="comment">// × 这个不行</span></span><br></pre></td></tr></table></figure>
<p>首先要弄懂赋值的概念，使用<code>=</code>的操作，其作用不是修改变量的值，而是改变了该变量名所参照的对象。在方法中改变参数的参照（进行赋值操作），我的理解是有两个问题：</p>
<ol>
<li>如果想通过方法的调用来改变参数的参照对象，可以通过返回值来进行赋值，直接在方法中使用<code>=</code>，调用方法的地方看不到该赋值操作，会降低代码的可读性。</li>
<li>如果是<strong>Pass By Value</strong>的编程语言，改变参数的参照（Reference），并不会影响到函数外的原变量。这就造成了混乱。</li>
</ol>
<h3 id="Pass-By-Value-Pass-By-Reference"><a href="#Pass-By-Value-Pass-By-Reference" class="headerlink" title="Pass By Value &amp;&amp; Pass By Reference"></a>Pass By Value &amp;&amp; Pass By Reference</h3><p>复习一下值传递和引用传递</p>
<ul>
<li>值传递<ul>
<li>方法的参数是变量值的拷贝，在方法内修改参数值不会影响方法外变量的值</li>
</ul>
</li>
<li>引用传递<ul>
<li>方法的参数时变量的地址，在方法内修改参数会直接影响该内存地址的内容，方法外变量的值也会改变。</li>
</ul>
</li>
</ul>
<p>Java是值传递的编程语言，对于基本数据类型的值传递很好理解，对于引用类型的参数，<a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/51192130">java基本数据类型传递与引用传递区别</a> 这篇文章里有个图很有助于理解</p>

<p>方法的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java中的按值调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zejian</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallByValue</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> User user=<span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User student)</span>&#123;</span><br><span class="line">		student.setName(<span class="string">&quot;Lishen&quot;</span>);</span><br><span class="line">		student.setAge(<span class="number">18</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">26</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;调用前user的值：&quot;</span>+user.toString());</span><br><span class="line">		updateUser(user);</span><br><span class="line">		System.out.println(<span class="string">&quot;调用后user的值：&quot;</span>+user.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以把引用类型的对象看作是一个值，引用类型的参数所传递的，是这个对象（图中的user），这就是引用类型的值传递。<br>通过<code>student</code>调用对象的方法是可以修改<code>user</code>内容的，但如果使用<code>=</code>来对<code>student</code>进行赋值，只是让<code>student</code>指向了一个新的对象，并不会影响到<code>user</code>。为了防止参数赋值造成混乱，Java其实可以将参数设置为<code>final</code>，只不过好像没怎么见谁用过…</p>
<h2 id="把方法换成对象"><a href="#把方法换成对象" class="headerlink" title="把方法换成对象"></a>把方法换成对象</h2><p>如果一个方法中有太多的局部变量，以至于无法通过提取方法进行重构（可是不进行重构方法又太丑陋了），不妨把方法整体提取为一个独立的对象，局部变量变为该对象的属性后，就可以在对象内轻松地提取方法进行下一步的重构了。</p>
<p>书中例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Account</span><br><span class="line">    <span class="type">int</span> <span class="title function_">gamma</span> <span class="params">(<span class="type">int</span> inputVal, <span class="type">int</span> quantity, <span class="type">int</span> yearToDate)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">importantValue1</span> <span class="operator">=</span> (inputVal * quantity) + delta();</span><br><span class="line">        <span class="type">int</span> <span class="variable">importantValue2</span> <span class="operator">=</span> (inputVal * yearToDate) + <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> ((yearToDate - importantValue1) &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">importantValue3</span> <span class="operator">=</span> importantValue2 * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// and so on.</span></span><br><span class="line">        <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果想要将计算返回值的部分提取出来，就需要将好多局部变量作为参数传递，非常复杂。我们可以使用对象来替代方法，首先写一个<code>Gamma</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gamma</span>...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Account _account;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> inputVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> quantity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> yearToDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> importantValue1;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> importantValue2;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> importantValue3;</span><br></pre></td></tr></table></figure>
<p>再为<code>Gamma</code>类添加一个构造体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Gamma (Account source, <span class="type">int</span> inputValArg, <span class="type">int</span> quantityArg, <span class="type">int</span> yearToDateArg) &#123;</span><br><span class="line">        _account = source; <span class="comment">// 为了使用方法delta()</span></span><br><span class="line">        inputVal = inputValArg;</span><br><span class="line">        quantity = quantityArg;</span><br><span class="line">        yearToDate = yearToDateArg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后将原方法的处理内容转移到<code>Gamma</code>中，作为一个待重构的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compute</span> <span class="params">()</span> &#123;</span><br><span class="line">        importantValue1 = (inputVal * quantity) + _account.delta();</span><br><span class="line">        importantValue2 = (inputVal * yearToDate) + <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> ((yearToDate - importantValue1) &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">importantValue3</span> <span class="operator">=</span> importantValue2 * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// and so on.</span></span><br><span class="line">        <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时，由于局部变量都已经变成了<code>Gamma</code>类的属性，我们提取方法时不需要再担心局部变量了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compute</span> <span class="params">()</span> &#123;</span><br><span class="line">       importantValue1 = (inputVal * quantity) + _account.delta();</span><br><span class="line">       importantValue2 = (inputVal * yearToDate) + <span class="number">100</span>;</span><br><span class="line">       importantThing();</span><br><span class="line">       <span class="type">int</span> <span class="variable">importantValue3</span> <span class="operator">=</span> importantValue2 * <span class="number">7</span>;</span><br><span class="line">       <span class="comment">// and so on.</span></span><br><span class="line">       <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">importantThing</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> ((yearToDate - importantValue1) &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>书中用的是<strong>substitue algorithm</strong>, 意思是用简明易懂的写法来替代旧算法，并没有追求提高算法效率或者降低消耗，我在理解的时候把这个重构操作也归类为<strong>优化</strong>  </p>
<p>意思很简单：即使做的还是那些事儿，如果可以让你的算法看起来更容易理解，Just do it.</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Refactoring/" title="Refactoring">Refactoring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/重构/" title="重构">重构 </a><span>大约3402个字, 11分钟20秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/04/22/2019-04-22-C9/">代码重构 - 简化条件语句</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>原文 <a target="_blank" rel="noopener" href="https://books.google.co.jp/books/about/Refactoring.html?id=HmrDHwgkbPsC&printsec=frontcover&source=kp_read_button&redir_esc=y#v=onepage&q&f=false">publisher logo Refactoring: Improving the Design of Existing Code</a> Chapter 9 Simplifying Conditianal Expressions</p>
</blockquote>
<h2 id="分离条件-Decompose-Conditional"><a href="#分离条件-Decompose-Conditional" class="headerlink" title="分离条件 - Decompose Conditional"></a>分离条件 - Decompose Conditional</h2><p>很多程序之所以“复杂难懂”，是因为出现了“复杂难懂”的条件语句。当人们看到条件语句时，最想获取的信息是：if XXX 的时候，do YYY； else do ZZZ。所以简化条件语句最简单直接的方法就是把长长的判断语句或者大段大段的处理分离出来，留下最基本的<code>if else</code>结构，一目了然，至于具体的判断方法和处理内容，则去具体的方法中查看。</p>
<blockquote>
<p>遇到有嵌套结构的条件语句时，不妨先试试先整理成卫语句(Guard Clauses)，行不通再进行分解处理。</p>
</blockquote>
<p>比如我们遇到下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.before (SUMMER_START) || date.after(SUMMER_END))&#123;</span><br><span class="line">  charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  charge = quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对条件和判断后的代码分别施放<strong>Extract Method</strong>法术:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (notSummer(date))&#123;</span><br><span class="line">  charge = winterCharge(quantity);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  charge = summerCharge (quantity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">notSummer</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> date.before (SUMMER_START) || date.after(SUMMER_END);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">summerCharge</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> quantity * summerRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">winterCharge</span><span class="params">(<span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> quantity * winterRate + winterServiceCharge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，每次抽离出方法的时候，都不要忘记进行测试，<strong>保证重构不会影响原本的处理结果</strong>，很多时候条件语句并不是十分复杂，看起来好像没有抽离成为方法的必要，这就要看条件语句读起来是否顺畅易懂了，如果可以把原本机器感十足的语句变得更像一段流畅直白的描述，条件语句的重构就是有意义的。</p>
<h2 id="整合条件-Consolidate-Conditional-Expression"><a href="#整合条件-Consolidate-Conditional-Expression" class="headerlink" title="整合条件 - Consolidate Conditional Expression"></a>整合条件 - Consolidate Conditional Expression</h2><p>有些条件语句的虽然有着不同的判断条件，却执行着相同的动作。如果可以确定这些判断不需要完全的独立，不妨整合到一起，再抽离出一个方法，这样，条件语句就更有“一个判断”的感觉了。</p>
<p>比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disabilityAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (_seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (_monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (_isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br></pre></td></tr></table></figure>

<p>可以整合成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disabilityAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotEligableForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br></pre></td></tr></table></figure>

<p>整合的对象不仅仅是同等级的条件语句(使用ors），有一些嵌套的条件语句更有整合的必要（使用ands）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onVacation())</span><br><span class="line">    <span class="keyword">if</span> (lengthOfService() &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>如果内层的<code>if</code>只是起到筛选的作用，而没有产生分支，就可以将内层条件语句跟外层整合到一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onVacation() &amp;&amp; lengthOfService() &gt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>如果条件语句的处理只是返回不同的值，不妨使用<strong>三元运算符(ternary operator)</strong> 。不过要注意，三元运算符的使用因人而异，有些项目并不喜欢代码里出现三元运算符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (onVacation() &amp;&amp; lengthOfService() &gt; <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>


<h2 id="整合重复的条件语句块-Consolidate-Duplicate-Conditional-Fragments"><a href="#整合重复的条件语句块-Consolidate-Duplicate-Conditional-Fragments" class="headerlink" title="整合重复的条件语句块 Consolidate Duplicate Conditional Fragments"></a>整合重复的条件语句块 Consolidate Duplicate Conditional Fragments</h2><p>当条件语句的<code>if</code>和<code>else</code>里出现了相同的处理时，不妨试试将其移动到条件语句之前或者之后，使条件语句中的处理更有“分歧”的感觉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>send()</code>出现在具有分歧的处理之后，可以移动到条件语句的后面；如果出现在具有分歧的处理之前，则移动到条件语句的前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal())</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>

<p>如果无法确定整合的内容在前还是应该在后，不妨先看一看在条件语句块内，该内容的位置变化是否影响处理结果，<br>在不影响处理结果的前提下将要整合的内容前移或者后撤之后，再进行重构就可以了。</p>
<h2 id="移除控制标记-Remove-Control-Flag"><a href="#移除控制标记-Remove-Control-Flag" class="headerlink" title="移除控制标记 Remove Control Flag"></a>移除控制标记 Remove Control Flag</h2><p>如果你使用一个变量的值控制真假的判断，不妨考虑在变量值的修改处用<code>break</code>或者<code>return</code>来替代。</p>
<p>比如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkSecurity</span><span class="params">(String[] people)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! found) &#123;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line">             sendAlert();</span><br><span class="line">             found = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;John&quot;</span>))&#123;</span><br><span class="line">             sendAlert();</span><br><span class="line">             found = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用变量<code>found</code>来判断来逃离<code>for</code>循环，显然可以使用<code>break</code>来代替：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkSecurity</span><span class="params">(String[] people)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line">          sendAlert();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;John&quot;</span>))&#123;</span><br><span class="line">          sendAlert();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样不仅是代码看起来简洁了许多，也避免了后续得无意义的判断。当然，这里的条件语句还可以整合一下，就不细说了。  </p>
<p>有些时候控制标记不仅仅是用来充当真假的判断条件，也用来保存返回值，这种情况可以考虑在适当的时候使用<code>return</code>直接结束方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkSecurity</span><span class="params">(String[] people)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">found</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (found.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line">              sendAlert();</span><br><span class="line">              found = <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;John&quot;</span>))&#123;</span><br><span class="line">              sendAlert();</span><br><span class="line">              found = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    someLaterCode(found);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先把<code>for</code>循环的内容抽离出来：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkSecurity</span><span class="params">(String[] people)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">found</span> <span class="operator">=</span> foundMiscreant(people);</span><br><span class="line">    someLaterCode(found);</span><br><span class="line">&#125;</span><br><span class="line">String <span class="title function_">foundMiscreant</span><span class="params">(String[] people)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">found</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (found.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line">             sendAlert();</span><br><span class="line">             found = <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;John&quot;</span>))&#123;</span><br><span class="line">             sendAlert();</span><br><span class="line">             found = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到标记<code>found</code>成为了返回值，程序的意思很明显是：[如果<code>found</code>不是空的，就返回其内容], 所以我们可以直接返回要赋给<code>found</code>的值，取消<code>found</code>这个变量。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">foundMiscreant</span><span class="params">(String[] people)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line">           sendAlert();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (people[i].equals (<span class="string">&quot;John&quot;</span>))&#123;</span><br><span class="line">           sendAlert();</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细心观察 return 的位置， 你会有意想不到的收获</p>
</blockquote>
<h2 id="使用卫语句替代嵌套的条件语句-Replace-Nested-Conditional-with-Guard-Clauses"><a href="#使用卫语句替代嵌套的条件语句-Replace-Nested-Conditional-with-Guard-Clauses" class="headerlink" title="使用卫语句替代嵌套的条件语句 Replace Nested Conditional with Guard Clauses"></a>使用卫语句替代嵌套的条件语句 Replace Nested Conditional with Guard Clauses</h2><p>条件语句在程序中的使用可以有两种思路：</p>
<ol>
<li>用来处理明确的分支，程序往哪个方向走都有可能，完全取决于条件的真假。这种情况使用基本的<code>if else</code>来处理。</li>
<li>用来处理特殊情况，程序有着一个基本的前进方向，出现一些特殊情况时，需要立即返回特定值或者转为进行特定的处理。这种情况的条件语句，我们可以称之为 卫语句(guard clause)</li>
</ol>
<p>当我们遇到层层嵌套的<code>if else</code>语句时，可以梳理一下程序的语义，如果发现条件语句的作用不是用来产生“平等”的分支，而是一种“出现了这种情况就赶快退出去吧”的感觉的话，不妨将<code>if else</code>简化成<code>guard clause</code>.</p>
<blockquote>
<p>这里作者介绍的是 嵌套的条件语句 ，实际上使用卫语句的思路在单一<code>if-else</code>时也适用，每当我们写出一个完全体的<code>if-else</code>时，都应该思考一下条件语句属于那种类型，很多时候<code>if-else</code>的分歧处理都可以用<code>if</code>的卫语句解决。</p>
</blockquote>
<p>比如下面的这段代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getPayAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">double</span> result;</span><br><span class="line">  <span class="keyword">if</span> (_isDead) result = deadAmount();</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (_isSeparated) result = separatedAmount();</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (_isRetired) result = retiredAmount();</span><br><span class="line">          <span class="keyword">else</span> result = normalPayAmount();</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种梯田式的条件语句，而且处理的对象都是返回值，很明显可以使用卫语句来简化，我们从外向里，一层层的将<code>result</code>的赋值改为<code>return</code>，最后可以得到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getPayAmount</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (_isDead) <span class="keyword">return</span> deadAmount();  </span><br><span class="line">  <span class="keyword">if</span> (_isSeparated) <span class="keyword">return</span> separatedAmount();  </span><br><span class="line">  <span class="keyword">if</span> (_isRetired) <span class="keyword">return</span> retiredAmount();  </span><br><span class="line">  <span class="keyword">return</span> normalPayAmount();&#125;;</span><br></pre></td></tr></table></figure>

<p>使用卫语句进行重构并不局限于这一种情况，有时候我们可以发现条件语句筛选了部分情况来进行特定的处理，剩下的情况则返回默认值。这时我们可以考虑反转判断的条件式，来得到一个卫语句，今儿简化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">()</span> &#123;  </span><br><span class="line">  <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0.0</span>;  </span><br><span class="line">  <span class="keyword">if</span> (_capital &gt; <span class="number">0.0</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span> (_intRate &gt; <span class="number">0.0</span> &amp;&amp; _duration &gt; <span class="number">0.0</span>) &#123;     </span><br><span class="line">      result = (_income / _duration) * ADJ_FACTOR;    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中作者给出了详细的重构过程，这里就不细说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">()</span> &#123;    </span><br><span class="line">  <span class="keyword">if</span> (_capital &lt;= <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;    </span><br><span class="line">  <span class="keyword">if</span> (_intRate &lt;= <span class="number">0.0</span> || _duration &lt;= <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;    </span><br><span class="line">  <span class="keyword">return</span> (_income / _duration) * ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>工作中很常用到的一个思路就是，如果有一个大大的if框住了几乎整个方法的内容，一定要看看可不可以反转if的条件在最前面直接return，从{}中解放这段代码。</p>
</blockquote>
<h2 id="利用多态来重构条件语句-Replace-Conditional-with-Polymorphism"><a href="#利用多态来重构条件语句-Replace-Conditional-with-Polymorphism" class="headerlink" title="利用多态来重构条件语句 Replace Conditional with Polymorphism"></a>利用多态来重构条件语句 Replace Conditional with Polymorphism</h2><p>比如我们有下面这个结构, <code>Employee</code>的<code>type</code>为抽象类<code>EmployeeType</code>，被三个类实现，每个类返回的<code>typeCode</code>不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">abstract class EmployeeType&#123;</span><br><span class="line">  &#123;abstract&#125; int getTypeCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee&#123;</span><br><span class="line">  int payAmount()</span><br><span class="line">  int getType()</span><br><span class="line">  private EmployeeType type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Engineer extends EmployeeType&#123;</span><br><span class="line">  int getTypeCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Manager extends EmployeeType&#123;</span><br><span class="line">  int getTypeCode()</span><br><span class="line">&#125;</span><br><span class="line">class Salesman extends EmployeeType&#123;</span><br><span class="line">  int getTypeCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee --&gt; &quot;1&quot; EmployeeType : type</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><code>Employee</code>的方法<code>payAmount()</code>的内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">payAmount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> EmployeeType.ENGINEER:</span><br><span class="line">            <span class="keyword">return</span> _monthlySalary;</span><br><span class="line">        <span class="keyword">case</span> EmployeeType.SALESMAN:</span><br><span class="line">            <span class="keyword">return</span> _monthlySalary + _commission;</span><br><span class="line">        <span class="keyword">case</span> EmployeeType.MANAGER:</span><br><span class="line">            <span class="keyword">return</span> _monthlySalary + _bonus;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>type</code>的其实是<code>EmployeeType</code>子类的属性，所以我们可以将这个方法移动到<code>EmployeeType</code>中，利用子类来实现不同的处理。首先，移动方法到<code>EmployeeType</code>里，由于使用了<code>Employee</code>才有的属性，所以我们需要将<code>employee</code>作为参数传递进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (getTypeCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ENGINEER:</span><br><span class="line">            <span class="keyword">return</span> emp.getMonthlySalary();</span><br><span class="line">        <span class="keyword">case</span> SALESMAN:</span><br><span class="line">            <span class="keyword">return</span> emp.getMonthlySalary() + emp.getCommission();</span><br><span class="line">        <span class="keyword">case</span> MANAGER:</span><br><span class="line">            <span class="keyword">return</span> emp.getMonthlySalary() + emp.getBonus();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EmployeeType</code>是抽象类，所以我们要继续将方法<code>payAmout()</code>在具体的子类中进行实现，不过子类中就用不到<code>switch</code>了。在重构的过程中，我们可以在<code>EmployeeType</code>中添加例外处理，比如当我们在<code>Engineer</code>中实现了<code>payAmount()</code>后:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> ...</span><br><span class="line">  <span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span> &#123;      </span><br><span class="line">    <span class="keyword">return</span> emp.getMonthlySalary();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeType</span>...</span><br><span class="line">  <span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (getTypeCode()) &#123;</span><br><span class="line">          <span class="keyword">case</span> ENGINEER:</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span> (<span class="string">&quot;Should be being overridden&quot;</span>);</span><br><span class="line">          <span class="keyword">case</span> SALESMAN:</span><br><span class="line">             <span class="keyword">return</span> emp.getMonthlySalary() + emp.getCommission();</span><br><span class="line">          <span class="keyword">case</span> MANAGER:</span><br><span class="line">             <span class="keyword">return</span> emp.getMonthlySalary() + emp.getBonus();</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Incorrect Employee&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如此下去，直到在所有的子类中都实现了<code>payAmount</code>之后，将<code>EmployeeType</code>的方法改为<code>abstract</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeType</span>...  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> ...</span><br><span class="line">  <span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span> &#123;      </span><br><span class="line">    <span class="keyword">return</span> emp.getMonthlySalary();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salesman</span>...  </span><br><span class="line">  <span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span> &#123;      </span><br><span class="line">    <span class="keyword">return</span> emp.getMonthlySalary() + emp.getCommission();  </span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>...  </span><br><span class="line">  <span class="type">int</span> <span class="title function_">payAmount</span><span class="params">(Employee emp)</span> &#123;      </span><br><span class="line">    <span class="keyword">return</span> emp.getMonthlySalary() + emp.getBonus();  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="使用空对象-Introduce-Null-Object"><a href="#使用空对象-Introduce-Null-Object" class="headerlink" title="使用空对象 Introduce Null Object"></a>使用空对象 Introduce Null Object</h2><blockquote>
<p>空对象模式是一种需要小心使用的设计模式，而且在JavaSE8中引入<code>Optional&lt;&gt;</code>后，几乎用不到空对象。</p>
</blockquote>
<h2 id="插入断言-Introduce-Assertion"><a href="#插入断言-Introduce-Assertion" class="headerlink" title="插入断言 Introduce Assertion"></a>插入断言 Introduce Assertion</h2><blockquote>
<p>善用 <code>Assert.isTrue()</code>， 确保一些必须成立的前提条件，从而让后面的条件判断达到最简化。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-22</span><i class="fa fa-tag"></i><a class="tag" href="/tags/未填之坑/" title="未填之坑">未填之坑 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Refactoring/" title="Refactoring">Refactoring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/重构/" title="重构">重构 </a><span>大约2701个字, 9分钟0秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/04/15/2019-04-15-git-connect/">通过命令行从本地推送代码到GitHub</a></h3></div><div class="post-content"><div class="card"><p><p>首先，Git和GitHub不是一个东西。Git是一个版本管理系统，而GitHub是一个用来保存软件代码的平台。我们不妨把git看作是通讯技术，而github只是<strong>一个</strong>通讯服务商。也就是说除了github之外，还有很多的代码托管平台，大家都是用的git来上传下载代码，只不过github名气最大。</p>
<ul>
<li>为了不受各种不同的软件影响，这里说的都是通过命令行操作.</li>
<li>这里只介绍一些最基本的命令和用法，在命令后面加<code> --help</code>可以查看详细的文档.</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先要做的事安装<code>git</code>，下载地址在<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">这里</a>.</p>
<p>git安装完之后，打开命令行执行<code>git --version</code>看看是否可以查看git的版本，如果返回版本信息，就OK了. git会自己安装一个<code>git Bash</code>, 不过git的命令行并不局限于bash，windows下直接在cmd或者powershell都可以使用.</p>
<p>本地的代码推送到github时，github需要验证用户的信息. 就好比你可以每次进门都填一次我叫什么，我从哪儿来，我是干什么的，也可以提前登陆好身份信息，“哔”的一声刷脸进门，这个登录的身份信息就是<code>ssh key</code>.</p>
<p>接下来的操作分为三步：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://help.github.com/en/enterprise/2.15/user/articles/checking-for-existing-ssh-keys">确定本地是否已经有建立好的ssh key</a><ul>
<li>打开git Bash（这里需要用到Bash, windows的cmd是没有ls命令的) 输入<code>ls -al ~/.ssh</code> 这里一个搜索命令，返回名称为<code>.ssh</code>的目录信息。如果有<code>id_rsa.pub</code>文件，就说明已经有ssh key了.</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://help.github.com/en/enterprise/2.15/user/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">如果没有，建立一组新的ssh key</a><ul>
<li>执行命令<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>来生成一组ssh key，接下来直接按回车就可以了（文件位置使用默认位置不需要输入，passphrase默认空白，不设置，设置的话以后每次推送代码都要输密码）。</li>
<li>将生成的key登录到ssh-agent. 执行命令启动ssh-agent，windows：<code>eval $(ssh-agent -s)</code>  Mac或者Linux：<code>eval &quot;$(ssh-agent -s)&quot;</code>.然后执行命令添加key，Mac：<code>ssh-add -K ~/.ssh/id_rsa</code> windows或者Linux：<code>ssh-add ~/.ssh/id_rsa</code></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://help.github.com/en/enterprise/2.15/user/articles/adding-a-new-ssh-key-to-your-github-account">将建立好的ssh key登录到github</a><ul>
<li>将ssh key的内容复制到剪贴板. window可以使用命令：<code>clip &lt; ~/.ssh/id_rsa.pub</code> Mac可以使用：<code>pbcopy &lt; ~/.ssh/id_rsa.pub</code> Linux可以使用：<code>sudo apt-get install xclip </code> 和 <code>xclip -sel clip &lt; ~/.ssh/id_rsa.pub</code></li>
</ul>
</li>
</ol>
<p>添加到github这一步我们单独说一下，以防弄错。打开github页面，点击用户头像，进入<code>setting</code>，在菜单中间的位置找到<code>SSH and GPG keys</code>，点击右上角的绿色按钮<code>New SSH key</code>，在<code>Title</code>里填写要添加的ssh key的介绍，比如”公司那台贼慢的电脑&#x2F;家里的老爷机&#x2F;学校的大屁股显示器”,然后在将复制的SSH key粘贴到<code>Key</code>里面，点击<code>Add SSH key</code>就可以了。</p>
<h2 id="克隆项目代码"><a href="#克隆项目代码" class="headerlink" title="克隆项目代码"></a>克隆项目代码</h2><p>我们来到<code>GitHub</code>的代码页，可以在代码的右上角看到一个绿色按钮<code>Clone or Download</code>，点开之后可以看到克隆代码用的链接。  </p>
<p>链接有两种，<code>https</code> 和 <code>ssh</code>， 简单来讲，使用https的链接克隆的项目需要用github的用户名密码来推送，使用ssh链接克隆的项目则使用ssh-key验证</p>




<p>由于我们已经设置好了ssh-key，所以使用格式为<code>git@github.com:用户名/项目名.github.io.git</code>的ssh链接.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:用户名/项目名.github.io.git</span><br></pre></td></tr></table></figure>

<h3 id="新建的repository"><a href="#新建的repository" class="headerlink" title="新建的repository"></a>新建的repository</h3><p>如果我们要将本地的工程文件推送到一个新建的GitHub库,首先确定两件事儿：</p>
<ol>
<li>GitHub上建立了一个空的库，README都没有的那种，可以看到这个页面 </li>
<li>本地的工程文件初始化了git，并且没有关联其他的库. git的初始化可以使用<code>git init</code>命令，移除其他的关联，可以使用<code>git remote remove name</code> 这里的name一般是<code>origin</code>.</li>
</ol>
<p>然后执行下面的命令就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin ssh链接</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="remote-和-local"><a href="#remote-和-local" class="headerlink" title="remote 和 local"></a>remote 和 local</h2><p>git管理的代码有两个地方: </p>
<ol>
<li>一个是<strong>remote</strong> 可以理解为远端，也就是指托管代码的地方，使用github时，值得也就是github服务器端</li>
<li>一个是<strong>local</strong> 直译本地，意译本地，他也就是本地的意思</li>
</ol>
<p>从远端向本地同步代码，叫做<code>pull</code> 也就是拉，将本地代码同步到远端，叫做<code>push</code> 推送，简单而形象。</p>
<p>local值不需要，当然也不能修改，因为代码就在本地. remote的值可以随时添加，删除或者修改，remote是name和url成对设置的，一般默认的remote名是origin</p>
<ul>
<li><code>git remote</code> 确认remote，会返回remote的名称</li>
<li><code>git remote get-url remoteName</code> 获得remote的url</li>
<li><code>git remote set-url remoteName url</code> 设置remote的url</li>
</ul>
<h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><p>为了实现并行的开发，代码通过<code>branch</code>（分支）来进行管理，不妨branch理解成时间线、河流，可分成几个分支并行前进，也可以随时汇集到一起（只要内容没有冲突）。<br>可以通过<code>git branch</code>来查当前本地的分支。<br>切换分支的命令为 <code>git checkout &quot;branch_name&quot;</code><br>常用的生成分支命令为 <code>git checkout -b &quot;new_branch_name&quot; &quot;base_branch_name&quot;</code><br>使用<code>git branch &quot;new_branch_name</code>也可以生成新的分支，不过该命令并不切换到新生成的分支.</p>
<ul>
<li>分支的名称不可以有空格，所以一般通过下划线连接单词，当分支名含有特殊符号比如 # 时，需要在分支名前后加 “ 来防止控制台执行时的歧义。</li>
</ul>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>如果说branch是时间线，那么commit就是时间线上的存档点。刚刚创建或者修改完的文件，在git中并不算<strong>保存</strong>了，如果强行修改分支，这些内容就会丢失。将修改的内容保存到branch的记录中的操作，叫做<code>commit（提交）</code>. </p>
<p>执行commit之前，首先需要把准备提交的文件添加到提交名单，这个操作使用 <code>git add</code> 命令。<br>添加之前，可以通过<code>git status</code>命令来查看有哪些文件被修改了.</p>
<p>这里简单的从bash颜色上区分一下，<br>绿色的内容(Changes to be committed) 是已经准备好可以提交的内容，<br>红色的内容(Changes not staged for commit) 是还没有添加到提交列表的修改.</p>
<p>下面介绍几种简单常用的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将所有的修改添加到提交列表</span><br><span class="line">git add --all</span><br><span class="line"></span><br><span class="line"># 将指定文件添加到提交列表，多个文件的时候使用空格区分</span><br><span class="line">git add aaa.md</span><br><span class="line">git add bbb.md ccc.md path/ddd.md</span><br><span class="line"></span><br><span class="line"># 可以使用正规表达来指定多个文件</span><br><span class="line">git add a*.md</span><br><span class="line">git add path/\*.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件添加完，就可以执行commit来提交了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 提交的时候，commit信息是必须的，可以直接使用-m 来指定commit信息</span><br><span class="line">git commit -m &quot;在这里输入一条commit信息&quot;</span><br><span class="line"></span><br><span class="line"># 使用github的时候，可以在commit信息里通过 #+编号 来关联Issue，这样提交的commit可以在Issue中直接找到。</span><br><span class="line">git commit -m &quot;#001 commmit信息&quot;</span><br></pre></td></tr></table></figure>

<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>将remote的最新内容同步到本地的命令是<code>git pull</code>，将本地的修改推送到remote的命令是<code>git push</code>.</p>
<ul>
<li>出现冲突的时候可以加上<code>--force</code>来强制推送，不过这个操作不推荐，推送代码尽可能在解决冲突之后，使用最简单流畅的<code>git push</code></li>
</ul>
<p>推送命令的对象是分支，所以当我们推送本地创建的新分支时，需要指定一下这个分支在remote的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># git push 推送命令</span><br><span class="line"># --set-upstream 告诉git 我要设置推送目的地</span><br><span class="line"># remotename 要推送到的remote名 一般是 origin</span><br><span class="line"># branch_name 推送的branch名 含有特殊字符的话要用&quot;branch_name&quot;</span><br><span class="line">git push --set-upstream remotename branch_name</span><br></pre></td></tr></table></figure>
<ul>
<li>无论是切换分支，还是推送的时候，如果前面命令输入正确，git bash可以补全分支名。所以多用<code>tab</code>不仅方便，还能帮忙检查一下分支名前面的命令行有没有错。</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-15</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Git/" title="Git">Git </a><i class="fa fa-tag"></i><a class="tag" href="/tags/GitHub/" title="GitHub">GitHub </a><span>大约2243个字, 7分钟28秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/04/12/2019-04-12-python-f-strings/">python 中的字符串格式化</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>原文： <a target="_blank" rel="noopener" href="https://realpython.com/python-f-strings/">python-f-string</a></p>
</blockquote>
<p>自<code>3.6</code>版本开始，python引入了一种叫做<code>f-strings</code>的写法，使用改写发可以极大地增强字符串的可读性（当然好处不止这些).<br>不过在学习<code>f-strings</code>之前，先看看以往的写法都有哪些。</p>
<h2 id="旧方法"><a href="#旧方法" class="headerlink" title="旧方法"></a>旧方法</h2><p>在<code>3.6</code>之前，我们常用的字符串格式化写法有两种：</p>
<ol>
<li>使用转移符 <code>%</code></li>
<li>使用字符串的格式化方法 <code>str.format()</code></li>
</ol>
<h3 id="旧选项1"><a href="#旧选项1" class="headerlink" title="旧选项1 %"></a>旧选项1 <code>%</code></h3><p>跟其他编程语言一样，python也可以用<code>%</code>来把变量值插入到字符串中的对应位置。写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello %s.&#x27;</span> % name)</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>输出多个变量时，在<code>%</code>后使用括号将所有变量放到一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">name2 = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">type1 = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">type2 = <span class="string">&#x27;god&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello %s, you are a %s.this is %s, a %s&#x27;</span> % (name1, type1, name2, type2))</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom, you are a cat. this is Jerry, a god&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是转移符这种东西，一个不小心就容易写错。</p>
<h3 id="旧选项2-str-format"><a href="#旧选项2-str-format" class="headerlink" title="旧选项2 str.format()"></a>旧选项2 <code>str.format()</code></h3><p>从<code>2.6</code>开始，python为字符串添加了一个<code>format()</code>方法，可以将引入的参数按顺序替换到字符串中的<code>&#123;&#125;</code>处。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">name2 = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">type1 = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">type2 = <span class="string">&#x27;god&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;&#125;, you are a &#123;&#125;.this is &#123;&#125;, a &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name1, type1, name2, type2))</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom, you are a cat. this is Jerry, a god&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>format()</code>你还可以自定义参数的插入顺序，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">name2 = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">type1 = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">type2 = <span class="string">&#x27;god&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;0&#125;, you are a &#123;2&#125;.this is &#123;1&#125;, a &#123;3&#125;&#x27;</span>.<span class="built_in">format</span>(name1, name2, type1, type2))</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom, you are a cat. this is Jerry, a god&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>format()</code>方法的功能还不止于此，既然<code>index</code>可以用来出入参数，那可不可以用参数名称呢？毕竟<code>0,1,2,3</code>的可读性有限。答案是可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">name2 = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">type1 = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">type2 = <span class="string">&#x27;god&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;name_a&#125;, you are a &#123;type_a&#125;.this is &#123;name_b&#125;, a &#123;type_b&#125;&#x27;</span>.<span class="built_in">format</span>(name_a = name1, name_b = name2, type_a = type1, type_b = type2))</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom, you are a cat. this is Jerry, a god&#x27;</span></span><br></pre></td></tr></table></figure>

<p>既然可以这样写了，那干脆直接引入<code>dict</code>得了.这个也是可以的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">character = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;type&#x27;</span> : <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello &#123;name&#125;, you are a &#123;type&#125;.&#x27;</span>.<span class="built_in">format</span>(**character))</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom, you are a cat.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样可读性就非常好了，不过在<code>3.6</code>版本，更好的写法出现了。</p>
<h2 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h2><p>关于<code>f-string</code>的引入，可以参看<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0498/">PEP498</a>, 或者<a target="_blank" rel="noopener" href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings">Python-doc</a>.  </p>
<p>写法非常简单，在字符串前加<code>f</code>或者<code>F</code>，在字符串中直接插入<code>&#123;变量名&#125;</code>，就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>, you are a <span class="subst">&#123;<span class="built_in">type</span>&#125;</span>.&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Tom, you are a cat.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在<code>&#123;&#125;</code>中不仅可以使用字符串，还可以使用运算公式，甚至调用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_name</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;change_name(name)&#125;</span>.&quot;</span>)</span><br><span class="line"><span class="comment"># 输出结果: &#x27;Hello Jerry.&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用<code>object</code>时，f-string会默认调用<code>__str__()</code>方法，如果想调用<code>__repr__</code>，需要在对象名后面加<code>!r</code>：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">f&quot;<span class="subst">&#123;<span class="built_in">object</span>&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 输出 object.__str__()的内容</span></span><br><span class="line"><span class="string">f&quot;<span class="subst">&#123;<span class="built_in">object</span>!r&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 输出 object.__repr__()的内容</span></span><br></pre></td></tr></table></figure></blockquote>
<p>最后一个考点：换行。在python中可以使用<code>&#39;&#39;&#39;</code>来输出带有换行的字符串，不过直接在前面加上f的结果并不怎么好看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Hi,</span></span><br><span class="line"><span class="string">you are a </span></span><br><span class="line"><span class="string">Cat</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># message : &#x27;\nHi, \nyou are a \nCat\n&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>f-string</code>的换行方法是，在每行的最后添加<code>\</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">f&#x27;&#x27;</span>\</span><br><span class="line"><span class="string">f&#x27;Hi &#x27;</span>\</span><br><span class="line"><span class="string">f&#x27;you are a &#x27;</span>\</span><br><span class="line"><span class="string">f&#x27;Cat &#x27;</span></span><br><span class="line"><span class="comment"># message ： &#x27;Hi you are a Cat&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 一般情况下<code>f-string</code>使用单引号和双引号没有区别，但比如引用字典，需要单引号来标记key时，f-stirng就需要使用双引号了，否则字符串中的单引号会被错误理解。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Python/" title="Python">Python </a><i class="fa fa-tag"></i><a class="tag" href="/tags/F-string/" title="F-string">F-string </a><span>大约1029个字, 3分钟25秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/04/05/2019-04-05-Hexo/">Hexo 说明文档笔记</a></h3></div><div class="post-content"><div class="card"><p><ul>
<li><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo 文档</a></li>
</ul>
<h2 id="theme文件夹结构"><a href="#theme文件夹结构" class="headerlink" title="theme文件夹结构"></a>theme文件夹结构</h2><ul>
<li>_config.yml</li>
<li>languages</li>
<li>layout</li>
<li>scripts</li>
<li>source</li>
</ul>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>主题的配置文件，修改主题的配置文件不需要重启服务器（修改网站根目录的那个_config.yml则需要重启才能生效)</p>
<h3 id="languages"><a href="#languages" class="headerlink" title="languages"></a>languages</h3><p>国际化设置，使用yml文件设置网站元素的翻译，具体参考<a target="_blank" rel="noopener" href="https://hexo.io/docs/internationalization">i18n</a></p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>网页、模板的设置。hexo默认使用Swig,不过也可以手动添加EJS,Haml,Jade或者Pug的支持。模板的写法参考 <a target="_blank" rel="noopener" href="https://hexo.io/docs/templates">Templates</a></p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>存放JavaScript代码的文件夹，Hexo会自动加载这里的javaScript文件。扩展功能参考 <a target="_blank" rel="noopener" href="https://hexo.io/docs/plugins">plugins</a></p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>顾名思义，这里是存放资源的。不属于页面模板的资源理论上都应该在此文件夹下面。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h3><p>在主题文件夹下的layout中定义不同模板的页面的呈现方式，具体的模板文件定义了页面的<code>body</code>内容，而layout则定义了如何显示<code>body</code>。<br>比如在布局中这样写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>&lt;%- body %&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>系统默认的布局为layout布局，不过在post的头部可以通过定义来使用具体的布局。</p>
<h3 id="Partial-组件"><a href="#Partial-组件" class="headerlink" title="Partial 组件"></a>Partial 组件</h3><p>不同页面之间共享的内容可以写成组件来管理，比如<code>Header</code>,<code>Footer</code>,<code>Sidebar</code>。<br>引用组件时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#x27;partial/header&#x27;) %&gt;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h2><p>从<code>Hexo 3 </code>开始，在<code>_config.yml</code>中启用<code>post_asset_folder=true</code>, 使用hexo的资源文件夹功能。<br>启用后，<code>_posts</code>里每生成一个post，会在相同路径下生成一个同名的文件夹作用该post的资源管理文件夹。</p>
<h3 id="引用资源文件夹中的资源"><a href="#引用资源文件夹中的资源" class="headerlink" title="引用资源文件夹中的资源"></a>引用资源文件夹中的资源</h3><p>启用了<code>asset_folder</code>后，可以使用以下几种命令，在文章中引用资源:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path name %&#125;</span><br><span class="line">&#123;% asset_img name title %&#125;</span><br><span class="line">&#123;% asset_link name title %&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>name</code>的地方填写资源文件夹内的相对路径。</p>
<p>比如以下的文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- sample.md</span><br><span class="line">- sample</span><br><span class="line">  - part1</span><br><span class="line">   - img.jpg</span><br></pre></td></tr></table></figure>

<p>在sample.md中引用img.jpg时的写法是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img part1\img.jpg this is title %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用资源文件夹与使用<code>markdown</code>的引用语法的最大不同就是：在网站首页或者归档处显示时，使用资源文件夹功能的引用可以被显示，而<code>markdown</code>语法引用的内容则无法被正确显示。</p>
<h3 id="样板"><a href="#样板" class="headerlink" title="样板"></a>样板</h3>


<h2 id="国际化-i18n"><a href="#国际化-i18n" class="headerlink" title="国际化 i18n"></a>国际化 i18n</h2><p><code>i18n</code> (Internationalization) 是指针对不同的国家、地域、语言环境，改变网站通用部分的显示语言。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>使用<code>YAML</code>或者<code>JSON</code>编写不同的语言文件，并统一放在主题文件夹<code>languages</code>中。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用<code>__</code>或者<code>_p</code>来取得对应语言的字符串。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu：</span><br><span class="line">  titile: HOME</span><br><span class="line">  archive: ARCHIVE</span><br><span class="line">  search: SEARCH</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu：</span><br><span class="line">  titile: 首页</span><br><span class="line">  archive: 归档</span><br><span class="line">  search: 搜索</span><br></pre></td></tr></table></figure>

<p>在模板中使用目录时（例如语言是英文）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= __(&#x27;menu.title&#x27;) %&gt; // HOME</span><br><span class="line">&lt;%= __(&#x27;menu.archive&#x27;) %&gt; // 归档</span><br><span class="line">&lt;%= __(&#x27;menu.search) %&gt; // 搜索 </span><br></pre></td></tr></table></figure>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-05</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Hexo/" title="Hexo">Hexo </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Gitpage/" title="Gitpage">Gitpage </a><span>大约781个字, 2分钟36秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/03/20/2019-03-20-Embadded-JavaScript/">Embadded-JavaScript</a></h3></div><div class="post-content"><div class="card"><p><h1 id="Ejs-文件是什么"><a href="#Ejs-文件是什么" class="headerlink" title="Ejs 文件是什么"></a>Ejs 文件是什么</h1><p>嵌入式JavaScript代码：Embadded JavaScript 是一种从JavaScript快速生成html的简易模板，详细说明可以阅读说明文档 <a target="_blank" rel="noopener" href="https://ejs.bootcss.com/">Ejs 中文文档</a>。<br>Hexo网页使用ejs的时候，使用命令 <code>npm install hexo-renderer-ejs --save</code>， 添加ejs的支持就可以了。这里作为备忘录，简单记录一下标签的写法。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul>
<li>&lt;% ‘脚本’ 标签，用于流程控制，无输出。</li>
<li>&lt;%_ 删除其前面的空格符</li>
<li>&lt;%&#x3D; 输出数据到模板（输出是转义 HTML 标签）</li>
<li>&lt;%- 输出非转义的数据到模板</li>
<li>&lt;%# 注释标签，不执行、不输出内容</li>
<li>&lt;%% 输出字符串 ‘&lt;%’</li>
<li>%&gt; 一般结束标签</li>
<li>-%&gt; 删除紧随其后的换行符</li>
<li>_%&gt; 将结束标签后面的空格符删除</li>
</ul>
<p>整理一下就是说，ejs代码就是写在html中的javascript，标签是<code>&lt;% %&gt;</code>,标签的开头和结尾有几中命令符可以使用，分别是</p>
<ol>
<li><code>_</code> 删除空格;</li>
<li><code>=</code>输出数据;</li>
<li><code>-</code> 在前：输出非转义数据（比如插入处理），在后：删除换行; </li>
<li><code>#</code> 注释; </li>
<li><code>%</code> 用于输出 <code>&lt;%</code></li>
</ol>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="自定义“转义符”-（官方文档写的是分隔符-delimiters，不是很理解）"><a href="#自定义“转义符”-（官方文档写的是分隔符-delimiters，不是很理解）" class="headerlink" title="自定义“转义符” （官方文档写的是分隔符-delimiters，不是很理解）"></a>自定义“转义符” （官方文档写的是分隔符-delimiters，不是很理解）</h2></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-03-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><i class="fa fa-tag"></i><a class="tag" href="/tags/未填之坑/" title="未填之坑">未填之坑 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Ejs/" title="Ejs">Ejs </a><span>大约337个字, 1分钟7秒读完</span></div></div></div></div><div class="post animated"><div class="post-title"><h3><a href="/2019/03/19/2019-03-19-jQuery-Memo/">jQuery 基本知识点备忘录</a></h3></div><div class="post-content"><div class="card"><p><h2 id="document-ready"><a href="#document-ready" class="headerlink" title="$(document).ready()"></a>$(document).ready()</h2><p>页面载入需要首先准备DOM（Document Object Model),jQuery可以检测到页面的DOM是否准备完毕，<code>$(document).ready(function)</code>中的function，会等到页面的DOM准备完毕再运行。<br>类似的还有<code>$(window).on(&quot;load&quot;,funciton)</code>,这种写法下的function会在整个页面（并不仅仅是DOM）载入完毕时再执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$( <span class="variable language_">document</span> ).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;document loaded&quot;</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$( <span class="variable language_">window</span> ).<span class="title function_">on</span>( <span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;window loaded&quot;</span> );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>将上面的代码插入页面的某个部件里执行，可以看到document很快就载入完成，等页面的所有其他元素都载入完成，<code>window loaded</code>才会被执行输出。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-03-19</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JavaScript/" title="JavaScript">JavaScript </a><i class="fa fa-tag"></i><a class="tag" href="/tags/jQuery/" title="jQuery">jQuery </a><i class="fa fa-tag"></i><a class="tag" href="/tags/未填之坑/" title="未填之坑">未填之坑 </a><span>大约176个字, 35秒读完</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/page/3/">上一页</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/5/">下一页</a></li></ul></div></div></div></div></main-outlet><script>(async function(){ if (Anatolo.search == null) await Anatolo.getMsg("search-init"); Anatolo.search.config = {translation:{posts:"文章",pages:"页面",categories:"分类",tags:"标签",untitled:"(无标题)",} }; })()</script><div class="searchbox ins-search modal-cover"><div class="searchbox-container ins-search-container modal-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="Anatolo.search.closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><button class="float-button hide" id="scroll-to-top" onclick="window.scrollTo({top: 0, behavior: 'smooth'})" type="button" title="回到顶部"><i class="fa fa-angle-up"></i></button><div class="modal-cover" id="success-indicator"><div class="modal-container indicator"><i class="fa fa-check"></i></div></div></body></html>